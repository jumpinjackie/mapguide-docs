{
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the MapGuide API Reference | MapGuide API Reference",
    "keywords": "Welcome to the MapGuide API Reference The MapGuide API is available for the following languages/platforms below Choose your language/platform .net API reference PHP API reference Java API reference"
  },
  "topics/TODO.html": {
    "href": "topics/TODO.html",
    "title": "TODO | MapGuide API Reference",
    "keywords": "TODO Oops! If you got here it means we haven't updated the original link"
  },
  "topics/bib-dana99.html": {
    "href": "topics/bib-dana99.html",
    "title": "Dana99 | MapGuide API Reference",
    "keywords": "Dana99 Dana, P. H., The Geographer's Craft Project, Department of Geography, The University of Colorado at Boulder, c1999, http://www.colorado.edu/geography/gcraft/notes/datum/datum_f.html"
  },
  "topics/bib-egenhofer91.html": {
    "href": "topics/bib-egenhofer91.html",
    "title": "Egenhofer91 | MapGuide API Reference",
    "keywords": "Egenhofer91 Egenhofer, M.F. and Franzosa, R.D., Point Set Topological Spatial Relations, International Journal of Geographical Information Systems, vol 5, no 2, 161-174, 1991."
  },
  "topics/bib-jts14.html": {
    "href": "topics/bib-jts14.html",
    "title": "JTS14 | MapGuide API Reference",
    "keywords": "JTS14 Vivid Solutions, \"JTS Topology Suite Technical Specifications\", Version 1.4, 2003. Version 1.4 of this specification at http://www.geotools.org/Working+with+JTS+Geometries+from+DataStores The latest version of this specification is at http://www.vividsolutions.com/JTS/JTSHome.htm"
  },
  "topics/bib-ogc96-015r1.html": {
    "href": "topics/bib-ogc96-015r1.html",
    "title": "OGC96015R1 | MapGuide API Reference",
    "keywords": "OGC96015R1 OpenGIS Consortium Inc., \"The OpenGIS Abstract Specification: An Object Model For Interoperable Geoprocessing,\" Revision 1, OpenGIS Project Document Number 96-015R1, 1966. Document Notice Public documents on the OGC site are provided by the copyright holders under the following license. The software or Document Type Definitions (DTDs) associated with OGC specifications are governed by the Software Notice. By using and/or copying this document, or the OGC document from which this statement is linked, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions: Permission to use, copy, and distribute the contents of this document, or the OGC document from which this statement is linked, in any medium for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the document, or portions thereof, that you use: Include a link or URL to the original OGC document. The pre-existing copyright notice of the original author, or if it doesn't exist, a notice of the form: \"Copyright � <date-of-document> Open Geospatial Consortium, Inc. All Rights Reserved. http://www.opengeospatial.org/ogc/document (Hypertext is preferred, but a textual representation is permitted.) If it exists, the STATUS of the OGC document. When space permits, inclusion of the full text of this NOTICEshould be provided. We request that authorship attribution be provided in any software, documents, or other items or products that you create pursuant to the implementation of the contents of this document, or any portion thereof. No right to create modifications or derivatives of OGC documents is granted pursuant to this license. However, if additional requirements (documented in the Copyright FAQ) are satisfied, the right to create modifications or derivatives is sometimes granted by the OGC to individuals complying with those requirements. THIS DOCUMENT IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF. The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to this document or its contents without specific, written prior permission. Title to copyright in this document will at all times remain with copyright holders."
  },
  "topics/bib-ogc99-049.html": {
    "href": "topics/bib-ogc99-049.html",
    "title": "OGC99049 | MapGuide API Reference",
    "keywords": "OGC99049 Open GIS Consortium Inc., \"OpenGIS Simple Features Specification for SQL\", Revision 1.1, OpenGIs Project Document 99-049, May 5, 1999. To obtain this document, go to http://www.opengeospatial.org/specs/. Click on \"OpenGIS Specifications,\" and then click on \"Simple Features - SQL.\" Document Notice Public documents on the OGC site are provided by the copyright holders under the following license. The software or Document Type Definitions (DTDs) associated with OGC specifications are governed by the Software Notice. By using and/or copying this document, or the OGC document from which this statement is linked, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions: Permission to use, copy, and distribute the contents of this document, or the OGC document from which this statement is linked, in any medium for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the document, or portions thereof, that you use: Include a link or URL to the original OGC document. The pre-existing copyright notice of the original author, or if it doesn't exist, a notice of the form: \"Copyright � <date-of-document> Open Geospatial Consortium, Inc. All Rights Reserved. http://www.opengeospatial.org/ogc/document (Hypertext is preferred, but a textual representation is permitted.) If it exists, the STATUS of the OGC document. When space permits, inclusion of the full text of this NOTICEshould be provided. We request that authorship attribution be provided in any software, documents, or other items or products that you create pursuant to the implementation of the contents of this document, or any portion thereof. No right to create modifications or derivatives of OGC documents is granted pursuant to this license. However, if additional requirements (documented in the Copyright FAQ) are satisfied, the right to create modifications or derivatives is sometimes granted by the OGC to individuals complying with those requirements. THIS DOCUMENT IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF. The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to this document or its contents without specific, written prior permission. Title to copyright in this document will at all times remain with copyright holders."
  },
  "topics/bib-osugr.html": {
    "href": "topics/bib-osugr.html",
    "title": "OSUGR | MapGuide API Reference",
    "keywords": "OSUGR \"Oracle Spatial User Guide and Reference\", 10g - Release 1 (10.1), Part No. B10826-01, Dec 2003."
  },
  "topics/bib-peat.html": {
    "href": "topics/bib-peat.html",
    "title": "Peat | MapGuide API Reference",
    "keywords": "Peat Peat, Chris, Heavens Above website, http://www.heavens-above.com/gloss.asp?term=azimuth."
  },
  "topics/collections.html": {
    "href": "topics/collections.html",
    "title": "Collections | MapGuide API Reference",
    "keywords": "Collections One of the functions of collections is to serve as a repository for intermediate results. In this role, a collection is a helper class. An example is the construction of an MgLineString (.net, Java, PHP) geometry. From the perspective of construction, this geometry is a set of coordinates. The sequence of construction is: create a coordinate add coordinate to coordinate collection do 1 and 2 until all coordinates created create the line string using coordinate collection See Geometry Collections for the list of collections used in the construction of geometries."
  },
  "topics/cs-testvalues.html": {
    "href": "topics/cs-testvalues.html",
    "title": "CSTestValues | MapGuide API Reference",
    "keywords": "CSTestValues These values are used for testing the coordinate system API. Geodetic Coordinate System Used in the PHP Sample Code The following well-known text represents a coordinate system based on longitude and latitude whose name is \"Longitude / Latitude (NAD 83)\". The horizontal datum used to measure positions on the surface of the earth is named \"NAD 83\". The earth's surface is modeled as a squashed sphere. The name of the model is \"GRS 80\". The \"GRS 80\" model has a semi-major axis value of 6378137 and an inverse flattening value of 298.257222101. The longitudinal measurement is taken from the Greenwich prime meridian. The Greenwich prime meridian is at an angle of 0.000000 degrees relative to the reference (Greenwich) prime meridian. The unit of measurement is an angular type whose name is \"Decimal Degree\", which can be converted to radians by applying the scalar factor of 0.01745329251994330. SQL\\> select cs_name,srid, wktext from mdsys.cs_srs where srid = 8265; cs_name = Longitude / Latitude (NAD 83) srid=8265 wktext= GEOGCS [ \"Longitude / Latitude (NAD 83)\", DATUM \"NAD 83\", SPHEROID [ \"GRS 80\", 6378137, 298.257222101 ] ], PRIMEM [ \"Greenwich\", 0.000000 ], UNIT [ \"Decimal Degree\", 0.01745329251994330 ] ] Used in the C# Sample Code The following well-known text represents a coordinate system based on longitude and latitude whose name is \"LL83\". The horizontal datum used to measure positions on the surface of the earth is named \"NAD83\". The earth's surface is modeled as a squashed sphere. The name of the model is \"GRS 80\". The \"GRS 80\" model has a semi-major axis value of 6378137 and an inverse flattening value of 298.257222101. The longitudinal measurement is taken from the Greenwich prime meridian. The Greenwich prime meridian is at an angle of 0.000000 degrees relative to the reference (Greenwich) prime meridian. The unit of measurement is an angular type whose name is \"Decimal Degree\", which can be converted to radians by applying the scalar factor of 0.01745329251994330. GEOGCS [ \"LL83\", DATUM [ \"NAD83\", SPHEROID [ \"GRS1980\", 6378137.000, 298.25722210 ] ], PRIMEM [ \"Greenwich\", 0 ], UNIT [ \"Degree\", 0.01745329251994 ] ] Projected Coordinate System Used in the PHP Sample Code The following well-known text represents a projected coordinate system whose name is \"UTM Zone 18 (NAD 83)\". It uses a parameterized transform called \"Transverse Mercator\" to transform geographic coordinates into the projected coordinates. The source coordinates are expressed in terms of a geographic coordinate system whose name is \"NAD 83 (Continental US).\" based on longitude and latitude whose name is \"Longitude / Latitude (NAD 83)\". The \"Transverse Mercator\" transform takes three parameters. The name of the first parameter is \"Scale_Factor\", and its value is 0.999600. The name of the second parameter is \"Central_Meridian\", and its value is -117.000000. The name of the third parameter is \"False_Easting\", and its value is 500000.000000. The unit of measurement is a linear type whose name is \"Meter\", which can be converted to meters by applying the scalar factor of 1.000000000000. SQL\\> select cs_name,srid, wktext from mdsys.cs_srs where srid = 82217; cs_name=UTM Zone 11 (NAD 83) srid=82254 wktext= PROJCS[ \"UTM Zone 18 (NAD 83)\", GEOGCS [ \"NAD 83 (Continental US)\", DATUM [ \"NAD 83 (Continental US)\", SPHEROID [ \"GRS 80\", 6378137, 298.257222101 ] ], PRIMEM [ \"Greenwich\", 0.000000 ], UNIT [ \"Decimal Degree\", 0.01745329251994330 ] ], PROJECTION [ \"Transverse Mercator\" ], PARAMETER [ \"Scale_Factor\", 0.999600 ], PARAMETER [ \"Central_Meridian\", \\-75.000000 ], PARAMETER [ \"False_Easting\", 500000.000000 ], UNIT [ \"Meter\", 1.000000000000 ] ] Used in the C# Sample Code The following well-known text represents a projected coordinate system whose name is \"UTM83-4\". It uses a parameterized transform called \"Transverse Mercator\" to transform geographic coordinates into the projected coordinates. The source coordinates are expressed in terms of a geographic coordinate system whose name is \"LL83\". The \"Transverse Mercator\" transform takes five parameters. The name of the first parameter is \"false_easting\", and its value is 500000.000. The name of the second parameter is \"false_northing\", and its value is 0.000. The name of the third parameter is \"central_meridian\", and its value is -159.00000000000000. The name of the fourth parameter is \"scale_factor\", and its value is 0.9996. The name of the fifth parameter is \"latitude_of_origin\", and its value is 0.000. The unit of measurement is a linear type whose name is \"Meter\", which can be converted to meters by applying the scalar factor of 1.000000000000. PROJCS[ \"UTM83-4\", GEOGCS[ \"LL83\", DATUM[ \"NAD83\", SPHEROID[ \"GRS1980\", 6378137.000, 298.25722210 ] ], PRIMEM[ \"Greenwich\", 0 ], UNIT[ \"Degree\", 0.017453292519943295 ] ], PROJECTION[ \"Transverse_Mercator\" ], PARAMETER[ \"false_easting\", 500000.000 ], PARAMETER[ \"false_northing\", 0.000 ], PARAMETER[ \"central_meridian\", -159.00000000000000 ], PARAMETER[ \"scale_factor\", 0.9996 ], PARAMETER[ \"latitude_of_origin\", 0.000 ], UNIT[ \"Meter\", 1.00000000000000 ] ] Arbitrary Coordinate System The following well-known text represents a local, ungeoreferenced coordinate system whose name is \"Non-Earth (Mile).\" The horizontal datum used to measure positions in the coordinate system is named \"Local Datum\". The type of the horizontal datum is 0. The unit of measurement is a linear type whose name is \"Mile\", which can be converted to meters by applying the scalar factor of 1.609344e+03. The system has two AXIS values indicating that it is two-dimensional. The directional value associated with the \"X\" AXIS signifies that \"X\" increases positively in value moving east from the origin. The directional value associated with the \"Y\" AXIS signifies that \"Y\" increases positively in value moving north from the origin. select cs_name, srid, wktext from mdsys.cs_srs where wktext like '%LOCAL_CS%'; cs_name=Non-Earth (Mile) srid=262156 wktext= LOCAL_CS [ \"Non-Earth (Mile)\", LOCAL_DATUM [ \"Local Datum\", 0 ] UNIT [ \"Mile\", 1.609344e+03 ], AXIS [ \"X\", EAST ], AXIS[ \"Y\", NORTH ] ]"
  },
  "topics/cs-wkttosrs.html": {
    "href": "topics/cs-wkttosrs.html",
    "title": "WKT of SRS | MapGuide API Reference",
    "keywords": "WKT of SRS This extended BNF grammar represents the syntax of a Well-Known Text (WKT) specification of a Spatial Reference System (SRS), also known as a coordinate system. The grammar is taken verbatim from OGC01009 and is reproduced here for convenience. <math transform> = <param mt> | <concat mt> | <inv mt> | <passthrough mt> <param mt> = PARAM_MT[\"<classification name>\" {,<parameter>}* ] <parameter> = PARAMETER[\"<name>\", <value>] <value> = <number> <concat mt> = CONCAT_MT[<math transform> {,<math transform>}* ] <inv mt> = INVERSE_MT[<math transform>] <passthrough mt> = PASSTHROUGH_MT[<integer>, <math transform>] <coordinate system> = <horz cs> | <geocentric cs> | <vert cs> | <compd cs> | <fitted cs> | <local cs> <horz cs> = <geographic cs> | <projected cs> <projected cs> = PROJCS[\"<name>\", <geographic cs>, <projection>, {<parameter>,}* <linear unit> {,<twin axes>}{,<authority>}] <projection> = PROJECTION[\"<name>\" {,<authority>}] <geographic cs> = GEOGCS[\"<name>\", <datum>, <prime meridian>, <angular unit> {,<twin axes>} {,<authority>}] <datum> = DATUM[\"<name>\", <spheroid> {,<to wgs84>} {,<authority>}] <spheroid> = SPHEROID[\"<name>\", <semi-major axis>, <inverse flattening> {,<authority>}] <semi-major axis> = <number> <inverse flattening> = <number> <prime meridian> = PRIMEM[\"<name>\", <longitude> {,<authority>}] <longitude> = <number> <angular unit> = <unit> <linear unit> = <unit> <unit> = UNIT[\"<name>\", <conversion factor> {,<authority>}] <conversion factor> = <number> <geocentric cs> = GEOCCS[\"<name>\", <datum>, <prime meridian>, <linear unit> {,<axis>, <axis>, <axis>} {,<authority>}] <authority> = AUTHORITY[\"<name>\", \"<code>\"] <vert cs> = VERT_CS[\"<name>\", <vert datum>, <linear unit>, {<axis>,} {,<authority>}] <vert datum> = VERT_DATUM[\"<name>\", <datum type> {,<authority>}] <datum type> = <number> <compd cs> = COMPD_CS[\"<name>\", <head cs>, <tail cs> {,<authority>}] <head cs> = <coordinate system> <tail cs> = <coordinate system> <twin axes> = <axis>, <axis> <axis> = AXIS[\"<name>\", NORTH | SOUTH | EAST | WEST | UP | DOWN | OTHER] <to wgs84s> = TOWGS84[<seven param>] <seven param> = <dx>, <dy>, <dz>, <ex>, <ey>, <ez>, <ppm> <dx> = <number> <dy> = <number> <dz> = <number> <ex> = <number> <ey> = <number> <ez> = <number> <ppm> = <number> <fitted cs> = FITTED_CS[\"<name>\", <to base>, <base cs>] <to base> = <math transform> <base cs> = <coordinate system> <local cs> = LOCAL_CS[\"<name>\", <local datum>, <unit>, <axis>, {,<axis>}* {,<authority>}] <local datum> = LOCAL_DATUM[\"<name>\", <datum type> {,<authority>}]"
  },
  "topics/feature-connection.html": {
    "href": "topics/feature-connection.html",
    "title": "Connection to Feature Source | MapGuide API Reference",
    "keywords": "Connection to Feature Source About feature sources A feature source contains feature data. The term 'feature source' refers to a feature data resource in the site server repository. The feature source is installed in the repository using the resource service (MgResourceService). What constitutes a feature source varies depending on the nature of the actual data source. For example, some data sources are text files, some are binary files, and some are relational databases. If the data source is a file, the file itself is stored in the repository. If the data source is a relational database, a connection specification is stored in the repository. Some relational databases support partitioning into multiple data sources. Each partition requires a separate connection specification. Storing and identifying feature sources In addition to features sources, the site server repository contains many other objects, which are collectively referred to as resources and identified by resource identifiers (MgResourceIdentifier) (.net, Java, PHP). The resource identifier specifies the location of a resource in the repository by using a URL. The feature source URL is of the form Library:://.../<featureSourceName>.FeatureSource. The ellipsis (...) represents an optional folder structure contained within the root Library folder. An example identifier is Library://FeatureService/PointsMDB.FeatureSource. The FeatureSource extension is specific to the feature source resource. All of the methods in the MgFeatureService API that do actual work require an MgResourceIdentifier object as an argument. Before installing a feature source in the repository The MgFeatureService (.net, Java, PHP) API provides a TestConnection method for testing the connection parameter values for a feature source prior to installation in the repository. For file-based feature sources the connection value could be a file name, a folder name, or a symbolic name which is used by the provider to query the operating system for the file location. For relational database feature sources, possible connection values include host name, service name, service instance name, user name, password, and datastore name. The connection string used to connect to a feature source is specific to the feature source. Examples follow for various providers. The MgFeatureService API provides a GetConnectionPropertyValues method for listing the names of the feature source partitions within a relational database. You can then construct a connection string for each partition and test it using TestConnection After the installation of the feature source in the repository, connection is done by a different TestConnection(MgResourceIdentifier) method that takes the feature source's resource identifier as an argument. Installing the feature source in the repository Install a feature source in the repository by: Specifying the location of the feature source in the repository in a resource identifier. Uploading a feature source XML value containing the property values used to connect to and configure the feature source. The structure of a feature source XML value conforms to the FeatureSource XML schema. The element values vary according to the feature source type. Examples for each provider follow. Uploading an XML value containing values governing the security of the feature source. See the \\link ResourceDocumentHeader_schema ResourceDocumentHeader \\endlink and ResourceSecurity schema topics for a general discussion about the XML element definitions. See the contents of an example header file at the end of this topic. Uploading the file or files which constitute the feature source if the feature source is file-based. Upload the feature source property XML file and document header XML file using the MgResourceService::SetResource method Upload a feature source file using the MgResourceService::SetResourceData method. Examples for various providers Autodesk.Oracle.2.0 Provider The feature source is a relational database, which supports multiple partitions, referred to as datastores. Each datastore can be a feature source. You use Sysadmin.exe to create datastores and add usernames and passwords. The tool and documentation for doing these and other tasks is contained in the installation. For a typical installation, the path is C:\\\\Program Files\\\\Common Files\\\\Autodesk Shared\\\\GIS\\\\FDO\\\\2.0\\\\Oracle. Example Connection String Username=smith;Password=test;Service=TuxService;DataStore=TUX All parameters are required. The DataStore property value identifies the feature source partition within the database. This value can be retrieved from the database using the MgFeatureService::GetConnectionPropertyValues Method. The Service property value identifies an entry in the tnsnames.ora file located in the Oracle instance or Oracle client installation on the local host. Feature Source XML File The filename is TuxService.FeatureSource. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.Oracle.2.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>DataStore</Name> <Value>TUX</Value> </ConnectionProperty> <ConnectionProperty> <Name>Username</Name> <Value>smith</Value> </ConnectionProperty> <ConnectionProperty> <Name>Password</Name> <Value>test</Value> </ConnectionProperty> <ConnectionProperty> <Name>Service</Name> <Value>TuxService</Value> </ConnectionProperty> </ConnectionProperties> <Configuration/> <SpatialContext/> <LongTransaction/> </FeatureSource> Autodesk.ArcSDE.1.0 Provider The feature source is a relational database. Access to it is indirect. The provider talks to an ArcSDE client, which talks to the ArcSDE server, which talks to the feature source. Example Connection String Username=smith;Password=test;Server=otwhost1;Instance=sde_inst1;Datastore=Default Datastore All parameters are required. The Server value is a hostname whose IP address can be resolved using a network domain name server. The instance value must appear in the services file on the local host. The path is C:\\\\WINDOWS\\\\system32\\\\drivers\\\\etc\\\\services. An example entry is sde_inst1 5151/tcp \\#ArcSDE Server listening port. The Datastore property value identifies the feature source partition within the database. This value can be retrieved from the database using the MgFeatureService::GetConnectionPropertyValues Method. A value of Default Datastore indicates that only one partition exists. Feature Source XML File The filename is sde_inst1.FeatureSource <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.ArcSDE.1.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>Datastore</Name> <Value>Default Datastore</Value> </ConnectionProperty> <ConnectionProperty> <Name>Username</Name> <Value>smith</Value> </ConnectionProperty> <ConnectionProperty> <Name>Password</Name> <Value>test</Value> </ConnectionProperty> <ConnectionProperty> <Name>Server</Name> <Value>otwhost1</Value> </ConnectionProperty> <ConnectionProperty> <Name>Instance</Name> <Value>sde_inst1</Value> </ConnectionProperty> </ConnectionProperties> <Configuration/> <SpatialContext/> <LongTransaction/> </FeatureSource> Autodesk.Sdf.3.0 Provider The feature source is a file. As part of installing the feature source in the repository, the .sdf file is loaded into the repository. Example Connection String File=C:/SDFFeatureResources/testSDF.sdf;ReadOnly=FALSE The File parameter is mandatory, and the ReadOnly parameter defaults to FALSE. Feature Source XML File The ConnectionProperty element whose Name is File has a Value element that is a symbolic reference to the location of the .sdf file in the repository. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.Sdf.3.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>File</Name> <Value>%MG_DATA_FILE_PATH%</Value> </ConnectionProperty> <ConnectionProperty> <Name>ReadOnly</Name> <Value>FALSE</Value> </ConnectionProperty> </ConnectionProperties> <SpatialContext/> <LongTransaction/> </FeatureSource> Autodesk.Shp.1.0 Provider The feature source is a set of up to 4 related files, collectively referred to as shapefiles. They consist of a .shp file containing the shape geometry, the .shx file containing the shape row index, the .dbf file containing shape attributes in dBASE format, and the .prj file containing the coordinate system. It is possible to connect to a .shp file by itself. The SHP provider treats each .shp and associated .dbf file as a feature class with a single geometry property and optionally, with data attribute properties. The four files can be accessed by applications other than the provider. In addition the provider may create two files that are used by the provider and not by other applications: an .idx file containing a spatial index and an .xml configuration file containing a mapping of the SHP data in the .shp file and the DBF data in the .dbf file to feature classes and properties in the FDO data model. The connection string used as an argument to the TestConnection() method references a folder in the file system. As part of installing the feature source in the repository, the shapefiles (.shp, .shx, .dbf, and .prj files) are loaded into the repository. The value of the DefaultFileLocation element as specified in the feature source XML file is a symbolic reference to the location of the shapefiles in the repository. Example Connection String DefaultFileLocation=C:/SHPFeatureResources;TemporaryFileLocation=C:/SHPFeatureResources Feature Source XML File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.Shp.1.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>DefaultFileLocation</Name> <Value>%MG_DATA_FILE_PATH%</Value> </ConnectionProperty> <ConnectionProperty> <Name>TemporaryFileLocation</Name> </ConnectionProperty> </ConnectionProperties> <SpatialContext/> <LongTransaction/> </FeatureSource> Autodesk.RFP.1.0 Provider Example Connection String DefaultRasterFileLocation=C:/RasterFeatureResources Feature Source XML File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.RFP.1.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>DefaultRasterFileLocation</Name> <Value>%MG_DATA_FILE_PATH%</Value> </ConnectionProperty> </ConnectionProperties> <SpatialContext/> <LongTransaction/> </FeatureSource> Autodesk.ODBC.1.0 Provider Typically you use this provider is to access text-based feature source files. The essential first step is to use a Windows OS administrative tool to define a data source name. This action associates a symbolic name with a file path. You then use the symbolic name in the connection string and XML feature source file. On an XP computer, the path to the ODBC Data Source Administrator is Start > Settings > Control Panel > Administrative Tools > Data Sources (ODBC). You can create a User DSN (Data Source Name), a System DSN or File DSN in the ODBC Data Source Administrator dialog box. The sequence of clicks or data entry to create a User or System DSN for a Microsoft Access .mdb file is System DSN or User DSN/Add > Create New Data Source/Microsoft Access Driver (*.mdb) > Finish > ODBC Microsoft Access Setup/<type name> > Select > Select Database/<select folder> > <select file> > OK > ODBC Microsoft Access Setup/OK. The name that you enter is the DSN name and is used in the connection string and the XML feature source file. The sequence of clicks or data entry to create a User or System DSN for a dBase .dbf file is System DNS or User DSN/Add > Create New Data Source/Microsoft dBase Driver (*.dbf) > Finish > ODBC dBase Setup/<type name> > Save > Create New Data Source/Next > Finish > Select Directory> Select Database/<select folder> > <select file> > OK > ODBC dBase Setup/OK. If \"Select Directory\" is unavailable, clear \"Use Current Directory\". The name that you enter is the DSN name and is used in the connection string and XML feature source file. The sequence of clicks or data entry to create a File DSN for a Microsoft Access .mdb file is File DSN/Add > Create New Data Source/Microsoft Access Driver (*.mdb) > Next> Browse > Save As/<pick folder> > <type filename> Finish > ODBC Microsoft Access Setup/Select > Select Database/<select folder> > <select file> > OK > ODBC Microsoft Access Setup/OK. The filename that you enter will be given an extension of .dsn. Example Connection String DataSourceName=Country Feature Source XML File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <FeatureSource version=\"1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"FeatureSource-1.0.0.xsd\"> <Provider>Autodesk.ODBC.1.0</Provider> <ConnectionProperties> <ConnectionProperty> <Name>DataSourceName</Name> <Value>Country</Value> </ConnectionProperty> <ConnectionProperty> <Name>UserId</Name> </ConnectionProperty> <ConnectionProperty> <Name>Password</Name> </ConnectionProperty> </ConnectionProperties> <Configuration/> <SpatialContext/> <LongTransaction/> </FeatureSource> ResourceDocumentHeader XML File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <ResourceDocumentHeader xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance \" xsi:noNamespaceSchemaLocation=\"ResourceDocumentHeader-1.0.0.xsd\"> <Security> <Inherited>true</Inherited> </Security> </ResourceDocumentHeader> Examples The code samples here how to add feature sources to the repository. You connect to a feature source in the repository. For example code showing how to connect to a feature source, see MgFeatureService::TestConnection. The first example adds a resource to the repository for a connection to an FDO Provider for Oracle. Since the connection is to a relational database and not a file, you need only call MgResourceService::SetResource passing in the FeatureSource XML containing the property values for the connection to the provider. PHP code <?php // creating the resource in the repository for a // connection to an FDO Provider for Oracle // first arg to $resourceService->SetResource() $featSrcResIdArg = \"Library://FeatureService/testOracle.FeatureSource\"; $featSrcResId = new MgResourceIdentifier($featSrcResIdArg); // second arg to $resourceService->SetResource() $featSrcFileByteContent = new MgByteSource($pathToFeatSrcFile); $featSrcFileReaderContent = $featSrcFileByteContent->GetReader(); // third arg to $resourceService->SetResource() $headerPathByteContent = new MgByteSource($headerPath); $headerPathReaderContent = $headerPathByteContent->GetReader(); // add the resource to the repository $resourceService->SetResource($featSrcResId, $featSrcFileReaderContent, $headerPathReaderContent); ?> \\endcode \\htmlinclude ExampleBottom.html \\htmlinclude PHPExampleTop.html The second example adds a resource to the repository for a connection to an FDO Provider for SDF. Since the connection is to a file, you must call MgResourceService::SetResource passing in the FeatureSource XML containing the property values for the connection to the SDF file, and you must call MgResourceService::SetResourceData passing in the contents of the SDF file. \\code <?php // creating the resource in the repository for a // connection to an FDO Provider for SDF // first arg to $resourceService->SetResource() $featSrcResIdArg = \"Library://FeatureService/testSDF.FeatureSource\"; $featSrcResId = new MgResourceIdentifier($featSrcResIdArg); // second arg to $resourceService->SetResource() $featSrcFileByteContent = new MgByteSource($pathToFeatSrcFile); $featSrcFileReaderContent = $featSrcFileByteContent->GetReader(); // third arg to $resourceService->SetResource() $headerPathByteContent = new MgByteSource($headerPath); $headerPathReaderContent = $headerPathByteContent->GetReader(); // add the resource to the repository $resourceService->SetResource($featSrcResId, $featSrcFileReaderContent, $headerPathReaderContent); // add the contents of the SDF file to the repository $fileByteContent = new MgByteSource($pathToDataFile); $fileReader = $fileByteContent->GetReader(); $resourceService->SetResourceData($featSrcResId, $fileName, \"File\", $fileReader); ?> C# code using OSGeo.MapGuide; using OSGeo.MapGuide.Schema.FeatureSource; // The MgResourceService example code shows the creation of an instance. private MgResourceService resourceService; public void ConnectToSdfFeatureClassFile(MgResourceIdentifier resourceId, Boolean readOnly, String filename, String SDFProviderName) { FileInfo info = new FileInfo(fileName); // Check if the specified file exists if (!info.Exists) { throw new FileNotFoundException( string.Format(\"The specified file {1} doesn't exist.\", info.FullName)); } // an xml string containing values for the two SDF connection parameters: File and ReadOnly String featureSourceDefinition; // Build the feature source object model FeatureSourceType fsType = new FeatureSourceType(); fsType.Provider = SDFProviderName; // FDO provider name, case sensitive NameValuePairType p1 = new NameValuePairType(); p1.Name = \"ReadOnly\"; p1.Value = readOnly.ToString(); // non case sensitive NameValuePairType p2 = new NameValuePairType(); p2.Name = \"File\"; p2.Value = info.FullName; // Either double backslash or single backslash is OK for the file path fsType.Parameter = new NameValuePairType[] { p2, p1 }; // Serialize the feature source object model to xml string using (StringWriter writer = new StringWriter()) { XmlSerializer xs = new XmlSerializer(fsType.GetType()); xs.Serialize(writer, fsType); featureSourceDefinition = writer.ToString(); } // Add the resource to repository byte[] bytes = Utilities.StringToBytes(featureSourceDefinition); MgByteSource source = new MgByteSource(bytes, bytes.Length); resourceService.SetResource(resourceId, source.GetReader(), null); }"
  },
  "topics/feature-filters.html": {
    "href": "topics/feature-filters.html",
    "title": "Filters and Expressions | MapGuide API Reference",
    "keywords": "Filters and Expressions Use a filter to select a subset of the features in a datastore. Filters are used in calls to MgFeatureService::SelectFeatures() and MgFeatureService::SelectAggregate(). There are two types of filters: basic and spatial. Spatial Filter A spatial filter relates two geometries by way of a spatial operator. A spatial filter is set by a call to MgFeatureQueryOptions::SetSpatialFilter() or MgFeatureAggregateOptions::SetSpatialFilter(). These methods take 3 arguments: a name which identifies a geometry property of a feature in a datastore, a geometry object, and a spatial operation identifier. The effect of the filter is to select features from the datastore whose geometry property is related according to the spatial operator to the geometry object argument. For example, if the spatial operator is MgFeatureSpatialOperations::Within, and the geometry object's WKT representation is POLYGON((0 0, 2 0, 2 2, 0 2, 0 0)), then the effect of the filter is to select those features which have geometries within this polygon. Basic Filter Use non-geometry feature property names, data values, and operators to construct a filter string which is passed as an argument to the MgFeatureQueryOption::SetFilter() or MgFeatureAggregateOptions::SetFilter() method. For example, if FEATID is a feature property name, then the filter \"FEATID > 20\" selects the features whose FEATID has a value greater than 20. Expressions Expressions are subcomponents of a basic filter. One expression might constitute the entire filter, or several expressions can be strung together using operators. Basic Filter Grammar <Filter> ::= '(' Filter ')' | <LogicalOperator> | <SearchCondition> <LogicalOperator> ::= <BinaryLogicalOperator> | <UnaryLogicalOperator> <BinaryLogicalOperator> ::= <Filter> <BinaryLogicalOperations> <Filter> <SearchCondition> ::= <InCondition> | <ComparisonCondition> | <GeometricCondition> | <NullCondition> <InCondition> ::= <Identifier> IN '(' ValueExpressionCollection ')' <ValueExpressionCollection> ::= <ValueExpression> | <ValueExpressionCollection> ',' <ValueExpression> <ComparisonCondition> ::= <Expression> <ComparisonOperations> <Expression> <GeometricCondition> ::= <SpatialCondition> | <DistanceCondition> <NullCondition> ::= <Identifier> NULL <SpatialCondition> ::= <Identifier> <SpatialOperations> <Expression> <DistanceCondition> ::= <Identifier> <DistanceOperations> <Expression> <distance> <UnaryLogicalOperator> ::= NOT <Filter> <BinaryLogicalOperations> ::= AND | OR <ComparisionOperations> ::= = | <> | > | >= | < | <= | LIKE <SpatialOperations> ::= CONTAINS | CROSSES | DISJOINT | EQUALS | INTERSECTS | OVERLAPS | TOUCHES | WITHIN | COVEREDBY | INSIDE <DistanceOperations> ::= BEYOND | WITHINDISTANCE <distance> ::= BEYOND | WITHINDISTANCE Expression Grammar <Expression> ::= '(' Expression ')' | <UnaryExpression> | <BinaryExpression> | <Function> | <Identifier> | <ValueExpression> <BinaryExpression> ::= <Expression> '+' <Expression> | <Expression> '-' <Expression> | <Expression> '*' <Expression> | <Expression> '/' <Expression> <ValueExpression> ::= <LiteralValue> <LiteralValue> ::= <GeometryValue> | <DataValue> <GeometryValue> ::= GEOMFROMTEXT '(' STRING ')' <DataValue> ::= TRUE | FALSE | DATETIME | DOUBLE | INTEGER | STRING | BLOB | CLOB | NULL <Function> ::= <Identifier> '(' <ExpressionCollection> ')' <ExpressionCollection> ::= | <Expression> | <ExpressionCollection> ',' <Expression> <Identifier> ::= IDENTIFIER <UnaryExpression> ::= '-' <Expression> Operator Precedence The operator precedence from highest to lowest is: Negate NOT Multiply Divide Add Subtract = <> > >= < <= AND OR Filter and Expression Keywords The following case-insensitive keywords are reserved in the language. That is, they cannot be used as identifier or function names: AND BEYOND COMPARE CONTAINS COVEREDBY CROSSES DATA DISJOINT DISTANCE EQUALS FALSE GEOMFROMTEXT IN INSIDE INTERSECTS LIKE NOT NULL OR OVERLAPS RELATE SPATIAL TIME TIMESTAMP TOUCHES TRUE WITHIN WITHINDISTANCE STRING Strings are literal constants enclosed in single quotes. If you need to include a single quote character inside a string, you can double the character, for example, 'aaa''bbb'. IDENTIFIER An identifier can be any alphanumeric sequence of characters other than a keyword. Identifiers can be enclosed in double quotes to show special characters and white space. If you need to include a double quote character inside an identifier, you can double the character, for example \"abc\"\"def\". INTEGER Integers allow only decimal characters with an optional unary minus sign. Unary plus is not supported. If an integer is out of the 32-bit precision range, it is converted to floating point. DOUBLE Floating point numbers have a decimal point, can be signed (-), and include an optional exponent (e{[0-9]}). DATETIME Date and time are parsed using the standard literal strings: DATE 'YYYY-MM-DD' TIME 'HH:MM:SS[.sss]' TIMESTAMP 'YYYY-MM-DD HH:MM:SS[.sss]' CLOB/BLOB These data types are not currently supported. If you need to support binary input, use parameters. <Function> Some functions such as ceil, floor, concat, lower, and upper take as an argument the value of a property from a single feature and return a value related to the property value. Some functions such as avg, count, max, min, stddev, and sum take as an argument the values of a property from multiple features and return a single value related to the values of the group of property arguments. Function Description Double Avg(n) Average value of n, ignoring nulls Int64 Ceil(Double) Smallest integer >= Double String Concat(Str1, Str2) Concatenates Str1 and Str2 Int64 Count(expression) Number of features where expression is not null Int64 Floor(Double) Largest integer <= Double String Lower(Str) Str with all lowercase letters Double Min(expression) Minimum value of expression Double Max(expression) Maximum value of expression Double Stddev(n) Standard deviation of n, ignoring nulls Double Sum(n) Sum of values of n String Upper(Str) Str with all uppercase letters Examples PHP and C# sample code for the setting of filters for select operations is presented. The SQL expression equivalent to the PHP and C# code is also presented. PHP Code <?php $queryOptions = new MgFeatureQueryOptions(); $stringCollection = new MgStringCollection(); $wktReaderWriter = new MgWktReaderWriter(); ?> C# code using OSGeo.MapGuide; private MgFeatureQueryOptions queryOptions; private MgStringCollection stringCollection; private MgWktReaderWriter wktReaderWriter; private String featClassName = \"SdfFeatureClass\"; private MgResourceIdentifier featureSrcResourceId; private MgFeatureService featureService; stringCollection = new MgStringCollection(); queryOptions = new MgFeatureQueryOptions(); // the feature source has already been installed in the repository featureSrcResourceId = new MgResourceIdentifier(\"Library://PlatformApiDocTests/SdfFeatureClass.FeatureSource\"); wktReaderWriter = new MgWktReaderWriter(); <Identifier> NULL SometimesNULL is a string property. If you have not given a value to it when inserting certain features and you apply the filter, sometimesNULL NULL, you select those features. If you have given a value to it when inserting other features and you apply the filter, NOT sometimesNULL NULL, you select those other features. sqlplus> select sometimesnull from featclass where sometimesnull is null; PHP code <?php $queryOptions->AddFeatureProperty(\"sometimesNULL\"); $queryOptions->SetFilter(\"sometimesNULL NULL\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"SometimesNull\"); queryOptions.SetFilter(\"SometimesNull NULL\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); sqlplus> select sometimesnull from featclass where sometimesnull is not null; PHP code <?php $queryOptions->AddFeatureProperty(\"sometimesNULL\"); $queryOptions->SetFilter(\"NOT sometimesNULL NULL\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"SometimesNull\"); queryOptions.SetFilter(\"NOT SometimesNull NULL\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); <Identifier> LIKE <String> Identifier is the name of a property whose type is MgPropertyType::String. String contains a pattern. A percent character (%) in a pattern matches zero or more characters. An underscore character (_) matches one character. Description is a string property. There are 2 features with this property in the datastore, and the contents of the two properties are: \"POINT XY (1 1)\" and \"POLYGON XY ((0 0, 2 0, 2 2, 0 2, 0 0))\". The filter, Description LIKE '%POLYGON%', returns \"POLYGON XY ((0 0, 2 0, 2 2, 0 2, 0 0))\", the filter, NOT Description LIKE '%POLYGON%', returns \"POINT XY (1 1)\", and the filter, Description LIKE '%POL_GON%', returns \"POLYGON XY ((0 0, 2 0, 2 2, 0 2, 0 0))\". sqlplus> select Description from featclass where Description LIKE '%POLYGON%'; PHP code $queryOptions->AddFeatureProperty(\"Description\"); $queryOptions->SetFilter(\"Description LIKE '%POLYGON%'\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); C# code queryOptions.AddFeatureProperty(\"Description\"); queryOptions.SetFilter(\"Description LIKE '%POLYGON%'\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); sqlplus> select Description from featclass where Description NOT LIKE '%POLYGON%'; PHP code $queryOptions->AddFeatureProperty(\"Description\"); $queryOptions->SetFilter(\"NOT Description LIKE '%POLYGON%'\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); C# code queryOptions.AddFeatureProperty(\"Description\"); queryOptions.SetFilter(\"NOT Description LIKE '%POLYGON%'\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); sqlplus> select Description from featclass where Description LIKE '%POL_GON%'; PHP code $queryOptions->AddFeatureProperty(\"Description\"); $queryOptions->SetFilter(\"Description LIKE '%POL_GON%'\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); C# code queryOptions.AddFeatureProperty(\"Description\"); queryOptions.SetFilter(\"Description LIKE '%POL_GON%'\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); <Identifier> IN ( <ValueExpressionCollection> ) anInt16 is an Int16 property. In one feature instance the value of anInt16 is -7033. If you apply anInt16 IN ( -5995, -7033 ), you select this feature. sqlplus> select anInt16 from featclass where anInt16 in ( -5995, -7033 ); PHP code <?php $queryOptions->AddFeatureProperty(\"anInt16\"); $queryOptions->SetFilter(\"anInt16 IN ( -5995, -7033 )\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"anInt16\"); queryOptions.SetFilter(\"anInt16 IN ( -5995, -7033 )\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); <Identifier> > <DataValue> featid is an identity property. If you apply the filter, featid 20, you select the features whose featid has a value > 20. If you apply the filter, featid > 0 AND featid < 5, you select the features whose featid belongs to { 1, 2, 3, 4}. If you apply the filter, featid < 3 OR featid 3, you select features whose featid is not 3. aDateTime is a date property. There is a feature whose aDateTime property has the value 9/20/2005::10:9:34:0. If you apply the filter, aDateTime < '2005-09-21', you select this feature. sqlplus> select anInt16 from featclass where adatetime < '21-SEP-05'; PHP code <?php $queryOptions->AddFeatureProperty(\"anInt16\"); $queryOptions->SetFilter(\"aDateTime < '2005-09-21'\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"anInt16\"); queryOptions.SetFilter(\"aDateTime < '2005-09-21'\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); <Expression> < <DataValue> anInt16 is an Int16 property. Two features have non-NULL values for this property. One has a value -7033, and the other -5995. If you apply the filter, ( anInt16 + 1000 ) < -5995, you select the feature whose anInt16 property has the value -7033. The parentheses in this filter are optional because operator precedence would dictate that the filter, anInt16 + 1000 < -5995, is equivalent. sqlplus> select anInt16 from featclass where anInt16 + 1000 < -5995; PHP code <?php $queryOptions->AddFeatureProperty(\"anInt16\"); $queryOptions->SetFilter(\"anInt16 + 1000 < -5995\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"anInt16\"); queryOptions.SetFilter(\"anInt16 + 1000 < -5995\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); <FunctionValue> = <DataValue> aDouble is a double property. One feature has aDouble property with a value of 8103.08393. If you apply the filter, ceil(aDouble) = 8104, you select this feature. sqlplus> select aDouble from featclass where ceil(aDouble) = 8104; PHP code <?php $queryOptions->AddFeatureProperty(\"aDouble\"); $queryOptions->SetFilter(\"ceil(aDouble) = 8104\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"aDouble\"); queryOptions.SetFilter(\"ceil(aDouble) = 8104\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); Group Function aDouble is a double property. sum is a group function. sum(aDouble) sums the values of the aDouble property taken from a group of features. sqlplus> select sum(aDouble) from featclass; PHP code <?php $queryOptions->AddComputedProperty(\"sumDbl\", \"sum(aDouble)\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddComputedProperty(\"sumDbl\", \"sum(aDouble)\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process featureReader featureReader.Close(); Ordering aDouble is a double property. anInt32Key is the identity property. The first example returns aDouble values in ascending order, and the second example returns them in descending order. Ascending sqlplus> select anint32key,adouble from tuxuniversalclassxy order by adouble ASC; PHP code <?php $queryOptions->AddFeatureProperty(\"aDouble\"); $queryOptions->AddFeatureProperty(\"anInt32Key\"); $stringCollection->Add(\"aDouble\"); $queryOptions->SetOrderingFilter($stringCollection, MgOrderingOption::Ascending); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"aDouble\"); queryOptions.AddFeatureProperty(\"anInt32Key\"); stringCollection.Add(\"aDouble\"); queryOptions.SetOrderingFilter(stringCollection, MgOrderingOption::Ascending); featureReader = $featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process $featureReader featureReader.Close(); Descending sqlplus> select anint32key,adouble from tuxuniversalclassxy order by adouble DESC; PHP code <?php $queryOptions->AddFeatureProperty(\"aDouble\"); $queryOptions->AddFeatureProperty(\"anInt32Key\"); $stringCollection->Add(\"aDouble\"); $queryOptions->SetOrderingFilter($stringCollection, MgOrderingOption::Descending); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"aDouble\"); queryOptions.AddFeatureProperty(\"anInt32Key\"); stringCollection.Add(\"aDouble\"); queryOptions.SetOrderingFilter(stringCollection, MgOrderingOption::Descending); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process $featureReader featureReader.Close(); Basic Filter OR Spatial Filter featId is an identity property, and geometry is a geometry property. The feature whose featId value is 0 has a geometry value of POINT(1 1). The feature whose featid value is 1 has a null geometry value. The spatial filter requests features whose geometry intersects with POINT(1 1). The following select operation returns both of these features. The operation can be coded in two ways. The first way uses the SetFilter(), SetSpatialFilter() and SetBinaryOperator() methods, and the second way uses only the SetFilter() method. sqlplus> select a.featId from featclass a where a.featId = 1 or sdo_relate(a.geometry, MDSYS.SDO_GEOMETRY(2001, NULL, MDSYS.SDO_POINT_TYPE(1,1,NULL), NULL, NULL), 'mask=anyinteract') = 'TRUE'; PHP code <?php $queryOptions->AddFeatureProperty(\"featId\"); $queryOptions->SetFilter(\"featId = 1\"); $queryOptions->SetBinaryOperator(false); $geometry = $wktReaderWriter->Read(\"POINT(1 1)\"); $queryOptions->SetSpatialFilter(\"geometry\", $geometry, MgFeatureSpatialOperations::Intersects); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"featId\"); queryOptions.SetFilter(\"featId = 1\"); queryOptions.SetBinaryOperator(false); geometry = wktReaderWriter.Read(\"POINT(1 1)\"); queryOptions.SetSpatialFilter(\"geometry\", geometry, MgFeatureSpatialOperations::Intersects); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process $featureReader featureReader.Close(); PHP code <?php $queryOptions->AddFeatureProperty(\"featId\"); $queryOptions->SetFilter(\"(featId = 1) OR (geometry INTERSECTS GEOMFROMTEXT ( 'POINT(1 1)' )\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"featId\"); geometry = wktReaderWriter.Read(\"POINT(1 1)\"); queryOptions.SetFilter(\"(featId = 1) OR (geometry INTERSECTS GEOMFROMTEXT ( 'POINT(1 1)' )\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process $featureReader featureReader.Close(); Distance Filter featId is an identity property, and geometry is a geometry property. The feature whose featId value is 0 has a geometry value of POINT(1 1). The distance filter requests features whose geometry is within a distance of 1 from POINT(2 1). The following select operation returns the feature whose featId is 0. sqlplus> select a.featId from featclass a where sdo_within_distance(a.geometry, MDSYS SDO_GEOMETRY(2001, NULL, MDSYS.SDO_POINT_TYPE(2,1 NULL), NULL, NULL), 'distance=1') = 'TRUE'; PHP code <?php $queryOptions->AddFeatureProperty(\"featId\"); $queryOptions->SetFilter(\"geometry WITHINDISTANCE GEOMFROMTEXT ('POINT(2 1)') 1\"); $featureReader = $featureService->SelectFeatures($featureSrcResourceId, $featClassName, $queryOptions); # process $featureReader $featureReader->Close(); ?> C# code queryOptions.AddFeatureProperty(\"featId\"); queryOptions.SetFilter(\"geometry WITHINDISTANCE GEOMFROMTEXT ('POINT(2 1)') 1\"); featureReader = featureService.SelectFeatures(featureSrcResourceId, featClassName, queryOptions); // process $featureReader featureReader.Close();"
  },
  "topics/feature-intro.html": {
    "href": "topics/feature-intro.html",
    "title": "Feature Service | MapGuide API Reference",
    "keywords": "Feature Service The Feature Service provides an abstraction layer for the storage and retrieval of feature data in a technology-independent way. You can use the API to determine which storage technologies are available and which capabilities they have. Access to the storage technology is modeled as a connection. For example, you can connect to a file and do simple insertions or connect to a relational database and do transaction-based operations. The root methods are contained in the MgFeatureService (.net, Java, PHP) class. In general, you may do any of the following, subject to provider capability limitations: Determine which storage technologies are available (see MgFeatureService::GetFeatureProviders()), Determine which capabilities a feature provider has (see MgFeatureService::GetCapabilities()), Verify the connection property values (see MgFeatureService::GetConnectionPropertyValues()), Connect to a storage technology (feature provider) using MgFeatureService::TestConnection() Describe the structure of feature data using ``MgFeatureService::DescribeSchema()` Determine the spatial contexts available in the datastore (see MgFeatureService::GetSpatialContexts()), Insert feature data (see MgInsertFeatures (.net, Java, PHP)), Select feature data (see MgFeatureService::SelectFeatures() and MgFeatureService::SelectAggregate()), Update feature data (see MgUpdateFeatures (.net, Java, PHP)), Delete feature data (see MgDeleteFeatures (.net, Java, PHP)), Execute SQL commands (see MgFeatureService::ExecuteSqlQuery() and MgFeatureService::ExecuteSqlNonQuery())."
  },
  "topics/feature-properties.html": {
    "href": "topics/feature-properties.html",
    "title": "Feature Properties | MapGuide API Reference",
    "keywords": "Feature Properties A feature property is a key-value pair where the key is a property name as defined in a feature class definition, and the value is the property's value. The property's type is one of the classes derived from the base class MgProperty (.net, Java, PHP). The following list shows the names of the classes derived from MgProperty and, for each class, the type returned by the GetValue() method: Class Returns MgBlobProperty (.net, Java, PHP) MgByteReader (.net, Java, PHP) MgBooleanProperty (.net, Java, PHP) bool MgByteProperty (.net, Java, PHP) byte MgClobProperty (.net, Java, PHP) MgByteReader (.net, Java, PHP) MgDateTimeProperty (.net, Java, PHP) MgDateTime (.net, Java, PHP) MgDoubleProperty (.net, Java, PHP) double MgFeatureProperty (.net, Java, PHP) MgFeatureReader (.net, Java, PHP) MgGeometryProperty (.net, Java, PHP) MgByteReader (.net, Java, PHP) MgInt16Property (.net, Java, PHP) int16 MgInt32Property (.net, Java, PHP) int32 MgInt64Property (.net, Java, PHP) int64 MgRasterProperty (.net, Java, PHP) MgRaster (.net, Java, PHP) MgSingleProperty (.net, Java, PHP) float MgStringProperty (.net, Java, PHP) string"
  },
  "topics/feature-provider-registry.html": {
    "href": "topics/feature-provider-registry.html",
    "title": "Feature Provider Registry | MapGuide API Reference",
    "keywords": "Feature Provider Registry The feature provider registry contains most importantly the name of each available provider, version information and the name of the provider DLL. The full set of registry information elements and attributes is specified in the XML schema FeatureProviderRegistry. The FeatureProviders constructor takes the XML string containing the provider registry as an argument. It creates an array of FeatureProvider objects. Currently it only parses the Name elements from the registry information. PHP code <?php class FeatureProviders { var $xpath; var $featureProviders; var $logFileHandle; function arrayOfProviderNames() { return array_keys($this->featureProviders); } function FeatureProviders( $logFileHandle, $byteReader ) { $this->logFileHandle = $logFileHandle; $doc = new DOMDocument(); $xmlStr = $byteReader->ToString(); $doc->loadXML($xmlStr); $this->xpath = new DOMXPath($doc); $this->queryProviders(); } function queryProviders() { $providers = $this->xpath->query(\"//FeatureProviderRegistry/FeatureProvider\"); $count = $providers->length; for($i=0; $i<$count; $i++) { $provider = $providers->item($i); $providerElements = $provider->childNodes; $connectionProperties = NULL; foreach($providerElements as $providerElement) { $providerElemTagname = $providerElement->tagName; if ($providerElemTagname == \"Name\") { $providerName = $providerElement->nodeValue; $featureProvider = new FeatureProvider($providerName); } } $this->featureProviders[$providerName] = $featureProvider; } } } class FeatureProvider { var $providerName; var $connectionProperties = NULL; function FeatureProvider( $providerName ) { $this->providerName = $providerName; } function GetProviderName() { return $providerName; } } ?> The GetProviderNames method gets the provider registry from Feature Services. The registry is in xml and the method uses an xpath expression to retrieve the provider names. It concatenates the provider names for use in a test expression. The following string is an example of the output from this program. Autodesk.Oracle.3.2 Autodesk.Raster.3.2 Autodesk.SqlServer.3.2 OSGeo.ArcSDE.3.2 OSGeo.MySQL.3.2 OSGeo.ODBC.3.2 OSGeo.SDF.3.2 OSGeo.SHP.3.2 OSGeo.WFS.3.2 OSGeo.WMS.3.2 The utility method shows the use of System Xml classes to extract values from the xml. C# code using OSGeo.MapGuide; // The MgFeatureService example code shows how the MgFeatureService object is created. private MgFeatureService featureService; private String providerNamesActual; private void GetProviderNames() { System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(0x0409); String[] names; MgByteReader byteReader = featureService.GetFeatureProviders(); String xmlContent = byteReader.ToString(); names = GetXpathValuesRtnStrArr(xmlContent, \"//FeatureProviderRegistry/FeatureProvider/Name\"); providerCountActual = names.GetLength(0); Array.Sort(names, StringComparer.Create(culture, false)); providerNamesActual = StringArrayToString(names); } private String[] GetXpathValuesRtnStrArr(String xmlContent, String xpath) { System.Collections.ArrayList strList = new System.Collections.ArrayList(10); String[] strArr; System.Xml.XmlDocument xmlDocument = new XmlDocument(); xmlDocument.LoadXml(xmlContent); XmlNodeList nodeList; XmlElement root = xmlDocument.DocumentElement; nodeList = root.SelectNodes(xpath); int count = nodeList.Count; if (count == 0) { strArr = new String[] { \"\" }; return strArr; } XmlNode node; for (int i = 0; i < count; i++) { node = nodeList.Item(i); strList.Add(node.FirstChild.Value); } strArr = (String[])strList.ToArray(typeof(string)); return strArr; } GetProviderNames(); System.Console.WriteLine(providerNamesActual);"
  },
  "topics/feature-provider.html": {
    "href": "topics/feature-provider.html",
    "title": "Feature Providers | MapGuide API Reference",
    "keywords": "Feature Providers Provider Capabilities The MgFeatureService API delegates much of its functionality to FDO providers. The providers implement the storage and retrieval of feature data from a variety of RDBMS and file-based datastore technologies. A set of provider capabilities has been defined, and each provider has been characterized according to what capabilities it supports. For example, the FDO Provider for Oracle supports the creation, description, and destruction of a schema definition, but the FDO Provider for ArcSDE supports only the description of a schema definition. The capabilities are grouped in the following categories: Connection Schema Commands Expressions Filters Raster Topology The MgFeatureService::GetCapabilities method returns an XML representation of a provider's capabilities. See \\link FdoProviderCapabilities_schema FdoProviderCapabilities \\endlink for the definition of the XML representation. The capability characterization can be used to execute code conditionally depending on the provider being used and what capability is being executed. Example (C#) The GetFeatureProviders method cyles through the list of provider names and creates a FeatureProvider object for each one. The FeatureProvider constructor uses the MgFeatureService object to get the capabilities for the provider. The capabilities are in xml and the Extract methods use xpath expressions to extract the capability values from the xml. The utility methods show the use of System Xml classes to extract values from the xml. Here are a few of the capability strings generated by this code for the SDF provider. ConnectionCapabilities:ThreadCapability=PerConnectionThreaded;SpatialContextExtentType=Dynamic; CommandCapabilities:Commands=+Select+Insert+Delete+Update+DescribeSchema+ApplySchema+CreateSpatialContext+GetSpatialContexts+SelectAggregates;SelectExpressions;SelectFunctions;SelectDistinct; SchemaCapabilities:ClassType=+Class+FeatureClass;DataType=+Boolean+Byte+DateTime+Decimal+Double+Int16+Int32+Int64+Single+String;Inheritance;AssociationProperties;AutoIdGeneration;SupportedAutoGeneratedTypes=+Int32;SchemaModification; GeometryCapabilities:GeometryTypes=+Point+LineString+Polygon+MultiPoint+MultiLineString+MultiPolygon+MultiGeometry+CurveString+CurvePolygon+MultiCurveString+MultiCurvePolygon;ComponentType=+LinearRing+ArcSegment+LinearSegment+CurveRing;Dimensionality=XYZM; FilterCapabilities:ConditionType=+Comparison+Like+In+Null+Spatial;SpatialOperation=+Contains+Disjoint+Intersects+Within+Inside+EnvelopeIntersects;DistanceOperation=; ExpressionCapabilities:ExpressionType=+Basic+Function;FunctionDefinitions=+Concat+SpatialExtents+Ceil+Floor+Lower+Upper+Sum+Count+Min+Avg+Max; C# code using OSGeo.MapGuide; // The MgFeatureService example code shows how the MgFeatureService object is created. private MgFeatureService featureService; private String providerNamesActual; private ListDictionary featureProviders; private void GetProviderNames() { System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo(0x0409); String[] names; MgByteReader byteReader = featureService.GetFeatureProviders(); String xmlContent = byteReader.ToString(); names = GetXpathValuesRtnStrArr(xmlContent, \"//FeatureProviderRegistry/FeatureProvider/Name\"); providerCountActual = names.GetLength(0); Array.Sort(names, StringComparer.Create(culture, false)); providerNamesActual = StringArrayToString(names); } private void GetFeatureProviders() { featureProviders = new ListDictionary(); FeatureProvider featureProvider; String providerName; string[] names = providerNamesActual.Split(); for (int i = 0; i < providerCountActual; i++) { providerName = names[i]; featureProvider = new FeatureProvider(logger, providerName, featureService, utilities, timings); featureProviders.Add(providerName, featureProvider); } } class FeatureProvider { public FeatureProvider(... MgFeatureService featureService, Utilities utilities, ...) { ... MgByteReader byteReader = featureService.GetCapabilities(providerName); xmlContent = byteReader.ToString(); ExtractConnectionCapabilities(); ExtractSchemaCapabilities(); ExtractCommandCapabilities(); ExtractFilterCapabilities(); ExtractExpressionCapabilities(); ExtractRasterCapabilities(); ExtractTopologyCapabilities(); ExtractGeometryCapabilities(); } private MgFeatureService featureService; private String xmlContent; private String connectionCapabilitiesToStr; private String schemaCapabilitiesToStr; private String commandCapabilitiesToStr; private String filterCapabilitiesToStr; private String expressionCapabilitiesToStr; private String rasterCapabilitiesToStr; private String topologyCapabilitiesToStr; private String geometryCapabilitiesToStr; private StringBuilder sb; private const int sblength = 640; private Boolean multipleSchema; // public property declarations to expose capability strings private void ExtractConnectionCapabilities() { sb = new StringBuilder(sblength); sb.Append(\"ConnectionCapabilities:\"); String ThreadCapability = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/ThreadCapability\"); sb.Append(\"ThreadCapability=\" + ThreadCapability + ';'); String SpatialContextExtentType = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SpatialContextExtent/Type\"); sb.Append(\"SpatialContextExtentType=\" + SpatialContextExtentType + ';'); String SupportsLocking = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsLocking\"); if (SupportsLocking.Equals(\"true\")) { sb.Append(\"Locking;\"); } String SupportsTimeout = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsTimeout\"); if (SupportsTimeout.Equals(\"true\")) { sb.Append(\"Timeout;\"); } String SupportsTransactions = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsTransactions\"); if (SupportsTransactions.Equals(\"true\")) { sb.Append(\"Transactions;\"); } String SupportsLongTransactions = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsLongTransactions\"); if (SupportsLongTransactions.Equals(\"true\")) { sb.Append(\"LongTransactions;\"); } String SupportsSQL = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsSQL\"); if (SupportsSQL.Equals(\"true\")) { sb.Append(\"SQL;\"); } String SupportsConfiguration = utilities.GetXpathValuesRtnStr(xmlContent, \"Connection/SupportsConfiguration\"); if (SupportsConfiguration.Equals(\"true\")) { sb.Append(\"Configuration;\"); } connectionCapabilitiesToStr = sb.ToString(); } private void ExtractSchemaCapabilities() { String value; sb = new StringBuilder(sblength); sb.Append(\"SchemaCapabilities:\"); MgStringCollection ClassType = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Schema/Class/Type\"); sb.Append(\"ClassType=\"); int classCount = ClassType.GetCount(); for (int i = 0; i < classCount; i++) { sb.Append(\"+\" + ClassType.GetItem(i)); } sb.Append(\";\"); MgStringCollection DataType = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Schema/Data/Type\"); sb.Append(\"DataType=\"); int dataCount = DataType.GetCount(); for (int i = 0; i < dataCount; i++) { sb.Append(\"+\" + DataType.GetItem(i)); } sb.Append(\";\"); String SupportsInheritance = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsInheritance\"); if (SupportsInheritance.Equals(\"true\")) { sb.Append(\"Inheritance;\"); } String SupportsMultipleSchemas = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsMultipleSchemas\"); if (SupportsMultipleSchemas.Equals(\"true\")) { sb.Append(\"MultipleSchemas;\"); multipleSchema = true; } else { multipleSchema = false; } String SupportsObjectProperties = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsObjectProperties\"); if (SupportsObjectProperties.Equals(\"true\")) { sb.Append(\"ObjectProperties;\"); } String SupportsAssociationProperties = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsAssociationProperties\"); if (SupportsAssociationProperties.Equals(\"true\")) { sb.Append(\"AssociationProperties;\"); } String SupportsSchemaOverrides = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsSchemaOverrides\"); if (SupportsSchemaOverrides.Equals(\"true\")) { sb.Append(\"SchemaOverrides;\"); } String SupportsNetworkModel = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsNetworkModel\"); if (SupportsNetworkModel.Equals(\"true\")) { sb.Append(\"NetworkModel;\"); } String SupportsAutoIdGeneration = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsAutoIdGeneration\"); if (SupportsAutoIdGeneration.Equals(\"true\")) { sb.Append(\"AutoIdGeneration;\"); } String SupportsDataStoreUniqueIdGeneration = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsDataStoreUniqueIdGeneration\"); if (SupportsDataStoreUniqueIdGeneration.Equals(\"true\")) { sb.Append(\"DataStoreUniqueIdGeneration;\"); } MgStringCollection SupportedAutoGeneratedTypes = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Schema/SupportedAutoGeneratedTypes/Type\"); sb.Append(\"SupportedAutoGeneratedTypes=\"); int autoGenTypeCount = SupportedAutoGeneratedTypes.GetCount(); for (int i = 0; i < autoGenTypeCount; i++) { value = SupportedAutoGeneratedTypes.GetItem(i); if (value != \"\") { sb.Append(\"+\" + value); } } sb.Append(\";\"); String SupportsSchemaModification = utilities.GetXpathValuesRtnStr(xmlContent, \"Schema/SupportsSchemaModification\"); if (SupportsSchemaModification.Equals(\"true\")) { sb.Append(\"SchemaModification;\"); } schemaCapabilitiesToStr = sb.ToString(); } private void ExtractCommandCapabilities() { sb = new StringBuilder(sblength); sb.Append(\"CommandCapabilities:\"); MgStringCollection Commands = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Command/SupportedCommands/Name\"); sb.Append(\"Commands=\"); int cmdCount = Commands.GetCount(); for (int i = 0; i < cmdCount; i++) { sb.Append(\"+\" + Commands.GetItem(i)); } sb.Append(\";\"); String SupportsParameters = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsParameters\"); if (SupportsParameters.Equals(\"true\")) { sb.Append(\"Parameters;\"); } String SupportsTimeout = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsTimeout\"); if (SupportsTimeout.Equals(\"true\")) { sb.Append(\"Timeout;\"); } String SupportsSelectExpressions = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsSelectExpressions\"); if (SupportsSelectExpressions.Equals(\"true\")) { sb.Append(\"SelectExpressions;\"); } String SupportsSelectFunctions = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsSelectFunctions\"); if (SupportsSelectFunctions.Equals(\"true\")) { sb.Append(\"SelectFunctions;\"); } String SupportsSelectDistinct = GetXpathValuesRtnStr(xmlContent, \"Command/SupportsSelectDistinct\"); if (SupportsSelectDistinct.Equals(\"true\")) { sb.Append(\"SelectDistinct;\"); } String SupportsSelectOrdering = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsSelectOrdering\"); if (SupportsSelectOrdering.Equals(\"true\")) { sb.Append(\"SelectOrdering;\"); } String SupportsSelectGrouping = utilities.GetXpathValuesRtnStr(xmlContent, \"Command/SupportsSelectGrouping\"); if (SupportsSelectGrouping.Equals(\"true\")) { sb.Append(\"SelectGrouping;\"); } commandCapabilitiesToStr = sb.ToString(); } private void ExtractFilterCapabilities() { String value; sb = new StringBuilder(sblength); sb.Append(\"FilterCapabilities:\"); MgStringCollection ConditionType = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Filter/Condition/Type\"); sb.Append(\"ConditionType=\"); int conditionCount = ConditionType.GetCount(); for (int i = 0; i < conditionCount; i++) { value = ConditionType.GetItem(i); if (value != \"\") { sb.Append(\"+\" + value); } } sb.Append(\";\"); MgStringCollection SpatialOperation = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Filter/Spatial/Operation\"); sb.Append(\"SpatialOperation=\"); int spatialOpCount = SpatialOperation.GetCount(); for (int i = 0; i < spatialOpCount; i++) { value = SpatialOperation.GetItem(i); if (value != \"\") { sb.Append(\"+\" + value); } } sb.Append(\";\"); MgStringCollection DistanceOperation = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Filter/Distance/Operation\"); sb.Append(\"DistanceOperation=\"); int distanceOpCount = DistanceOperation.GetCount(); for (int i = 0; i < distanceOpCount; i++) { value = DistanceOperation.GetItem(i); if (value != \"\") { sb.Append(\"+\" + value); } } sb.Append(\";\"); String SupportsGeodesicDistance = utilities.GetXpathValuesRtnStr(xmlContent, \"Filter/SupportsGeodesicDistance\"); if (SupportsGeodesicDistance.Equals(\"true\")) { sb.Append(\"GeodesicDistance;\"); } String SupportsNonLinearGeometricOperations = utilities.GetXpathValuesRtnStr(xmlContent, \"Filter/SupportsNonLinearGeometricOperations\"); if (SupportsNonLinearGeometricOperations.Equals(\"true\")) { sb.Append(\"NonLinearGeometricOperations;\"); } filterCapabilitiesToStr = sb.ToString(); } private void ExtractExpressionCapabilities() { String value; sb = new StringBuilder(sblength); sb.Append(\"ExpressionCapabilities:\"); MgStringCollection ExpressionType = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Expression/Type/Name\"); sb.Append(\"ExpressionType=\"); int typeCount = ExpressionType.GetCount(); for (int i = 0; i < typeCount; i++) { sb.Append(\"+\" + ExpressionType.GetItem(i)); } sb.Append(\";\"); MgStringCollection FunctionDefinitions = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Expression/FunctionDefinitionCollection/FunctionDefinition/Name\"); sb.Append(\"FunctionDefinitions=\"); int functionCount = FunctionDefinitions.GetCount(); for (int i = 0; i < functionCount; i++) { value = FunctionDefinitions.GetItem(i); if (value != \"\") { sb.Append(\"+\" + value); } } sb.Append(\";\"); expressionCapabilitiesToStr = sb.ToString(); } private void ExtractRasterCapabilities() { sb = new StringBuilder(sblength); sb.Append(\"RasterCapabilities:\"); String SupportsRaster = utilities.GetXpathValuesRtnStr(xmlContent, \"Raster/SupportsRaster\"); if (SupportsRaster.Equals(\"true\")) { sb.Append(\"Raster;\"); } String SupportsStitching = utilities.GetXpathValuesRtnStr(xmlContent, \"Raster/SupportsStitching\"); if (SupportsStitching.Equals(\"true\")) { sb.Append(\"Stitching;\"); } String SupportsSubsmpling = utilities.GetXpathValuesRtnStr(xmlContent, \"Raster/SupportsSubsmpling\"); if (SupportsSubsmpling.Equals(\"true\")) { sb.Append(\"Subsmpling;\"); } rasterCapabilitiesToStr = sb.ToString(); } private void ExtractTopologyCapabilities() { sb = new StringBuilder(sblength); sb.Append(\"TopologyCapabilities:\"); String SupportsTopology = utilities.GetXpathValuesRtnStr(xmlContent, \"Topology/SupportsTopology\"); if (SupportsTopology.Equals(\"true\")) { sb.Append(\"Topology;\"); } String SupportsTopologicalHierarchy = utilities.GetXpathValuesRtnStr(xmlContent, \"Topology/SupportsTopologicalHierarchy\"); if (SupportsTopologicalHierarchy.Equals(\"true\")) { sb.Append(\"TopologicalHierarchy;\"); } String BreaksCurveCrossingsAutomatically = utilities.GetXpathValuesRtnStr(xmlContent, \"Topology/BreaksCurveCrossingsAutomatically\"); if (BreaksCurveCrossingsAutomatically.Equals(\"true\")) { sb.Append(\"BreaksCurveCrossingsAutomatically;\"); } String ActivatesTopologyByArea = utilities.GetXpathValuesRtnStr(xmlContent, \"Topology/ActivatesTopologyByArea\"); if (ActivatesTopologyByArea.Equals(\"true\")) { sb.Append(\"ActivatesTopologyByArea;\"); } String ConstrainsFeatureMovements = utilities.GetXpathValuesRtnStr(xmlContent, \"Topology/ConstrainsFeatureMovements\"); if (ConstrainsFeatureMovements.Equals(\"true\")) { sb.Append(\"ConstrainsFeatureMovements;\"); } topologyCapabilitiesToStr = sb.ToString(); } private void ExtractGeometryCapabilities() { sb = new StringBuilder(sblength); sb.Append(\"GeometryCapabilities:\"); MgStringCollection GeometryTypes = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Geometry/Types/Type\"); sb.Append(\"GeometryTypes=\"); int geomTypeCount = GeometryTypes.GetCount(); for (int i = 0; i < geomTypeCount; i++) { sb.Append(\"+\" + GeometryTypes.GetItem(i)); } sb.Append(\";\"); MgStringCollection ComponentType = utilities.GetXpathValuesRtnMgStrColl(xmlContent, \"Geometry/Components/Type\"); sb.Append(\"ComponentType=\"); int compTypeCount = ComponentType.GetCount(); for (int i = 0; i < compTypeCount; i++) { sb.Append(\"+\" + ComponentType.GetItem(i)); } sb.Append(\";\"); String Dimensionality = utilities.GetXpathValuesRtnStr(xmlContent, \"Geometry/Dimensionality\"); sb.Append(\"Dimensionality=\" + MgCoordinateDimensionToStr(Convert.ToInt32(Dimensionality)) + ';'); geometryCapabilitiesToStr = sb.ToString(); } } public String[] GetXpathValuesRtnStrArr(String xmlContent, String xpath) { System.Collections.ArrayList strList = new System.Collections.ArrayList(10); String[] strArr; System.Xml.XmlDocument xmlDocument = new XmlDocument(); xmlDocument.LoadXml(xmlContent); XmlNodeList nodeList; XmlElement root = xmlDocument.DocumentElement; nodeList = root.SelectNodes(xpath); int count = nodeList.Count; if (count == 0) { strArr = new String[] { \"\" }; return strArr; } XmlNode node; for (int i = 0; i < count; i++) { node = nodeList.Item(i); strList.Add(node.FirstChild.Value); } strArr = (String[])strList.ToArray(typeof(string)); return strArr; } public String GetXpathValuesRtnStr(String xmlContent, String xpath) { String value; System.Xml.XmlDocument xmlDocument = new XmlDocument(); xmlDocument.LoadXml(xmlContent); XmlElement root = xmlDocument.DocumentElement; XmlNode node; node = root.SelectSingleNode(xpath); if (node == null) { value = \"\"; return value; } value = node.FirstChild.Value; return value; } public MgStringCollection GetXpathValuesRtnMgStrColl(String xmlContent, String xpath) { MgStringCollection strings = new MgStringCollection(); System.Xml.XmlDocument xmlDocument = new XmlDocument(); xmlDocument.LoadXml(xmlContent); XmlNodeList nodeList; XmlElement root = xmlDocument.DocumentElement; nodeList = root.SelectNodes(xpath); int count = nodeList.Count; if (count == 0) { strings.Add(\"\"); return strings; } XmlNode node; for (int i = 0; i < count; i++) { node = nodeList.Item(i); strings.Add(node.FirstChild.Value); } return strings; } Capabilities for Autodesk.Oracle.2.0 What follows is a sample output from a PHP program used to get the capabilities for the Oracle provider. The program code follows the sample output. This program does the following: parses the XML returned by MgFeatureService::GetCapabilities() implements a set of boolean capability functions prints the values of the functions Connection ThreadCapability supportsSingleThreaded(): false supportsPerConnectionThreaded(): true supportsPerCommandThreaded(): false supportsMultiThreaded(): false SpatialContextExtent Type supportsDynamic(): false supportsStatic(): true supportsLocking(): true supportsConnectionTimeout(): false supportsTransactions(): true supportsLongTransactions(): true supportsSQL(): true supportsConfiguration(): false Schema Class Type supportsClass(): true supportsFeatureClass(): true Data Type supportsBoolean(): true supportsByte(): true supportsDateTime(): true supportsDecimal(): true supportsDouble(): true supportsInt16(): true supportsInt32(): true supportsInt64(): true supportsSingle(): true supportsString(): true supportsBLOB(): true supportsCLOB(): true supportsUniqueID(): false supportsInheritance(): true supportsMultipleSchemas(): true supportsObjectProperties(): true supportsAssociationProperties(): true supportsSchemaOverrides(): true supportsNetworkModel(): false supportsAutoIdGeneration(): true supportsDataStoreScopeUniqueIdGeneration(): true supportsSchemaModification(): true Command SupportedCommands Name supportsSelect(): true supportsInsert(): true supportsDelete(): true supportsUpdate(): true supportsSelectAggregates(): true supportsDescribeSchema(): true supportsDescribeSchemaMapping(): false supportsDestroySchema(): true supportsApplySchema(): true supportsActivateSpatialContext(): true supportsCreateSpatialContext(): true supportsDestroySpatialContext(): true supportsDestroySpatialContext(): true supportsCreateMeasureUnit(): false supportsDestroyMeasureUnit()t: false supportsGetMeasureUnits(): false supportsSQLCommand(): true supportsAcquireLock(): true supportsGetLockInfo(): true supportsGetLockedObjects(): true supportsGetLockOwners(): true supportsReleaseLock(): true supportsActivateLongTransaction(): true supportsCommitLongTransaction(): true supportsCreateLongTransaction(): true supportsGetLongTransactions(): true supportsFreezeLongTransaction(): false supportsRollbackLongTransaction(): true supportsActivateLongTransactionCheckpoint(): false supportsCreateLongTransactionCheckpoint(): false supportsGetLongTransactionCheckpoints(): false supportsRollbackLongTransactionCheckpoint(): false supportsChangeLongTransactionPrivileges(): false supportsGetLongTransactionPrivileges(): false supportsChangeLongTransactionSet(): false supportsGetLongTransactionsInSet(): false supportsFirstProviderCommand(): false supportsDeactivateLongTransaction(): true supportsParameters(): false supportsCommandTimeout(): false supportsSelectExpressions(): true supportsSelectFunctions(): true supportsSelectDistinct(): true supportsSelectOrdering(): true supportsSelectGrouping(): true Filter Condition Type supportsComparison(): true supportsLike(): true supportsIn(): true supportsNull(): true supportsSpatial(): true supportsDistance(): true Spatial Operation supportsContains(): false supportsCrosses(): false supportsDisjoint(): false supportsEquals(): false supportsIntersects(): true supportsOverlaps()s: false supportsTouches(): false supportsSpatialWithin(): false supportsCoveredBy(): true supportsInside(): true supportsEnvelopeIntersects(): true Distance Operation supportsDistanceWithin(): true supportsBeyond(): false supportsGeodesicDistance(): false supportsNonLiteralGeometricOperations(): false Expression Type Name supportsBasic(): true supportsFunction(): true supportsParameter(): true FunctionDefinitionCollection FunctionDefinition Name supportsAvg(): true supportsCeil(): true supportsCLIP(): false supportsConcat(): true supportsCount(): true supportsFloor(): true supportsLower(): true supportsMax(): true supportsMin(): true supportsMOSAIC(): false supportsStdDev(): false supportsSum(): true supportsUpper(): true Raster supportsRaster(): false supportsStitching(): false supportsSubsampling(): false Topology supportsTopology(): false supportsTopologicalHierarchy(): false supportsBreaksCurveCrossingsAutomatically(): false supportsActivatesTopologyByArea(): false supportsConstrainsFeatureMovements(): false Geometry Type supportsPoint(): true supportsMultiPoint(): true supportsLineString(): true supportsMultiLineString(): true supportsPolygon(): true supportsMultiPolygon(): true supportsCurveString(): true supportsMultiCurveString(): true supportsCurvePolygon(): true supportsMultiCurvePolygon(): true supportsMultiGeometry(): false Components Type supportsLinearRing(): true supportsLinearSegment(): true supportsArcSegment(): true supportsCurveRing(): true dimensionality(): 3 PHP Example Code This code does the following: parses the XML returned by MgFeatureService::GetCapabilities() implements a set of boolean capability functions prints the values of the functions The constructor takes a provider name, a file handle, and an MgByteReader containing the provider capabilities. The provider name is obtained from \\link MgFeatureService::GetFeatureProviders MgFeatureService::GetFeatureProviders\\endlink. The provider capabilities is obtained from \\link MgFeatureService::GetCapabilities MgFeatureService::GetCapabilities\\endlink. The file handle is for logging. PHP code class ProviderCapabilities { var $logFileHandle; var $xpath; var $providerName; function ProviderCapabilities( $providerName, $logFileHandle, $byteReader ) { try { $this-&gt;providerName = $providerName; $this-&gt;logFileHandle = $logFileHandle; $doc = new DOMDocument(); $byteSink = new MgByteSink($byteReader); $filePath = &quot;temp_byte_reader_file.$providerName&quot;; // fwrite($this-&gt;logFileHandle, &quot;file path is \\\\&quot;$filePath\\\\&quot;\\\\n&quot;); $byteSink-&gt;ToFile($filePath); $doc-&gt;load($filePath); // unlink($filePath); $this-&gt;xpath = new DOMXPath($doc); $this-&gt;queryConnection(); $this-&gt;querySchema(); $this-&gt;queryCommand(); $this-&gt;queryFilter(); $this-&gt;queryExpression(); $this-&gt;queryRaster(); $this-&gt;queryTopology(); $this-&gt;queryGeometry(); } catch (Exception $e) { $msg = $e-&gt;GetMessage(); fwrite($logFileHandle, &quot;ProviderCapabilities PHP Exception: $msg\\\\n&quot;); } } function prtBool($bool) { if ($bool) { return &quot;true&quot;; } else { return &quot;false&quot;; } } function queryBooleanElement($queryExpr, &amp;$reference) { $domNodeList = $this-&gt;xpath-&gt;query($queryExpr); if ($domNodeList-&gt;length == 0) return; $domNode = $domNodeList-&gt;item(0); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;true&quot; : $reference = TRUE; break; case &quot;false&quot; : $reference = FALSE; break; default : fwrite($this-&gt;logFileHandle, &quot;$queryExpr: unknown value: $value\\\\n&quot;); } } /* var $supports = FALSE; function supports() { return $this-&gt;supports; } \\*/ // CONNECTION CAPABILITIES // thread capability var $supportsSingleThreaded = FALSE; function supportsSingleThreaded() { return $this-&gt;supportsSingleThreaded; } var $supportsPerConnectionThreaded = FALSE; function supportsPerConnectionThreaded() { return $this-&gt;supportsPerConnectionThreaded; } var $supportsPerCommandThreaded = FALSE; function supportsPerCommandThreaded() { return $this-&gt;supportsPerCommandThreaded; } var $supportsMultiThreaded = FALSE; function supportsMultiThreaded() { return $this-&gt;supportsMultiThreaded; } // spatial context extent type var $supportsDynamic = FALSE; function supportsDynamic() { return $this-&gt;supportsDynamic; } var $supportsStatic = FALSE; function supportsStatic() { return $this-&gt;supportsStatic; } // rest of connection capabilities var $supportsLocking = FALSE; function supportsLocking() { return $this-&gt;supportsLocking; } var $supportsConnectionTimeout = FALSE; function supportsConnectionTimeout() { return $this-&gt;supportsConnectionTimeout; } var $supportsTransactions = FALSE; function supportsTransactions() { return $this-&gt;supportsTransactions; } var $supportsLongTransactions = FALSE; function supportsLongTransactions() { return $this-&gt;supportsLongTransactions; } var $supportsSQL = FALSE; function supportsSQL() { return $this-&gt;supportsSQL; } var $supportsConfiguration = FALSE; function supportsConfiguration() { return $this-&gt;supportsConfiguration; } function queryConnection() { $this-&gt;queryThreadCapability(); $this-&gt;querySpatialContextExtentType(); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsLocking&quot;, $this-&gt;supportsLocking); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsTimeout&quot;, $this-&gt;supportsConnectionTimeout); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsTransactions&quot;, $this-&gt;supportsTransactions); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsLongTransactions&quot;, $this-&gt;supportsLongTransactions); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsSQL&quot;, $this-&gt;supportsSQL); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Connection/SupportsConfiguration&quot;, $this-&gt;supportsConfiguration); } function queryThreadCapability() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Connection/ThreadCapability&quot;); if ($domNodeList-&gt;length == 0) return; $domNode = $domNodeList-&gt;item(0); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;PerConnectionThreaded&quot; : $this-&gt;supportsPerConnectionThreaded = TRUE; break; case &quot;SingleThreaded&quot; : $this-&gt;supportsSingleThreaded = TRUE; break; case &quot;PerCommandThreaded&quot; : $this-&gt;supportsPerCommandThreaded = TRUE; break; case &quot;MultiThreaded&quot; : $this-&gt;supportsMultiThreaded = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown thread type: $value\\\\n&quot;); } } function querySpatialContextExtentType() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Connection/SpatialContextExtent/Type&quot;); if ($domNodeList-&gt;length == 0) return; $domNode = $domNodeList-&gt;item(0); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Static&quot; : $this-&gt;supportsStatic = TRUE; break; case &quot;Dynamic&quot; : $this-&gt;supportsDynamic = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown spatial context extent type: $value\\\\n&quot;); } } // SCHEMA // class type var $supportsFeatureClass = FALSE; function supportsFeatureClass() { return $this-&gt;supportsFeatureClass; } var $supportsClass = FALSE; function supportsClass() { return $this-&gt;supportsClass; } // data types var $supportsBoolean = FALSE; function supportsBoolean() { return $this-&gt;supportsBoolean; } var $supportsByte = FALSE; function supportsByte() { return $this-&gt;supportsByte; } var $supportsDateTime = FALSE; function supportsDateTime() { return $this-&gt;supportsDateTime; } var $supportsDecimal = FALSE; function supportsDecimal() { return $this-&gt;supportsDecimal; } var $supportsDouble = FALSE; function supportsDouble() { return $this-&gt;supportsDouble; } var $supportsInt16 = FALSE; function supportsInt16() { return $this-&gt;supportsInt16; } var $supportsInt32 = FALSE; function supportsInt32() { return $this-&gt;supportsInt32; } var $supportsInt64 = FALSE; function supportsInt64() { return $this-&gt;supportsInt64; } var $supportsSingle = FALSE; function supportsSingle() { return $this-&gt;supportsSingle; } var $supportsString = FALSE; function supportsString() { return $this-&gt;supportsString; } var $supportsBLOB = FALSE; function supportsBLOB() { return $this-&gt;supportsBLOB; } var $supportsCLOB = FALSE; function supportsCLOB() { return $this-&gt;supportsCLOB; } var $supportsUniqueID = FALSE; function supportsUniqueID() { return $this-&gt;supportsUniqueID; } // rest of schema var $supportsInheritance = FALSE; function supportsInheritance() { return $this-&gt;supportsInheritance; } var $supportsMultipleSchemas = FALSE; function supportsMultipleSchemas() { return $this-&gt;supportsMultipleSchemas; } var $supportsObjectProperties = FALSE; function supportsObjectProperties() { return $this-&gt;supportsObjectProperties; } var $supportsAssociationProperties = FALSE; function supportsAssociationProperties() { return $this-&gt;supportsAssociationProperties; } var $supportsSchemaOverrides = FALSE; function supportsSchemaOverrides() { return $this-&gt;supportsSchemaOverrides; } var $supportsNetworkModel = FALSE; function supportsNetworkModel() { return $this-&gt;supportsNetworkModel; } var $supportsAutoIdGeneration = FALSE; function supportsAutoIdGeneration() { return $this-&gt;supportsAutoIdGeneration; } var $supportsDataStoreScopeUniqueIdGeneration = FALSE; function supportsDataStoreScopeUniqueIdGeneration() { return $this-&gt;supportsDataStoreScopeUniqueIdGeneration; } var $supportsSchemaModification = FALSE; function supportsSchemaModification() { return $this-&gt;supportsSchemaModification; } function querySchema() { $this-&gt;queryClassTypes(); $this-&gt;queryDataTypes(); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsInheritance&quot;, $this-&gt;supportsInheritance); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsMultipleSchemas&quot;, $this-&gt;supportsMultipleSchemas); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsObjectProperties&quot;, $this-&gt;supportsObjectProperties); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsAssociationProperties&quot;, $this-&gt;supportsAssociationProperties); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsSchemaOverrides&quot;, $this-&gt;supportsSchemaOverrides); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsNetworkModel&quot;, $this-&gt;supportsNetworkModel); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsAutoIdGeneration&quot;, $this-&gt;supportsAutoIdGeneration); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsDataStoreScopeUniqueIdGeneration&quot;, $this-&gt;supportsDataStoreScopeUniqueIdGeneration); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Schema/SupportsSchemaModification&quot;, $this-&gt;supportsSchemaModification); } function queryClassTypes() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Schema/Class/Type&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Class&quot; : $this-&gt;supportsClass = TRUE; break; case &quot;FeatureClass&quot; : $this-&gt;supportsFeatureClass = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown schema class type: $value\\\\n&quot;); } } } function queryDataTypes() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Schema/Data/Type&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Boolean&quot; : $this-&gt;supportsBoolean = TRUE; break; case &quot;Byte&quot; : $this-&gt;supportsByte = TRUE; break; case &quot;DateTime&quot; : $this-&gt;supportsDateTime = TRUE; break; case &quot;Decimal&quot; : $this-&gt;supportsDecimal = TRUE; break; case &quot;Double&quot; : $this-&gt;supportsDouble = TRUE; break; case &quot;Int16&quot; : $this-&gt;supportsInt16 = TRUE; break; case &quot;Int32&quot; : $this-&gt;supportsInt32 = TRUE; break; case &quot;Int64&quot; : $this-&gt;supportsInt64 = TRUE; break; case &quot;Single&quot; : $this-&gt;supportsSingle = TRUE; break; case &quot;String&quot; : $this-&gt;supportsString = TRUE; break; case &quot;CLOB&quot; : $this-&gt;supportsCLOB = TRUE; break; case &quot;BLOB&quot; : $this-&gt;supportsBLOB = TRUE; break; case &quot;UniqueID&quot; : $this-&gt;supportsUniqueID = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown data type: $value\\\\n&quot;); } } } // COMMAND var $supportsSelect = FALSE; function supportsSelect() { return $this-&gt;supportsSelect; } var $supportsSelectAggregates = FALSE; function supportsSelectAggregates() { return $this-&gt;supportsSelectAggregates; } var $supportsInsert = FALSE; function supportsInsert() { return $this-&gt;supportsInsert; } var $supportsDelete = FALSE; function supportsDelete() { return $this-&gt;supportsDelete; } var $supportsUpdate = FALSE; function supportsUpdate() { return $this-&gt;supportsUpdate; } var $supportsDescribeSchema = FALSE; function supportsDescribeSchema() { return $this-&gt;supportsDescribeSchema; } var $supportsDescribeSchemaMapping = FALSE; function supportsDescribeSchemaMapping() { return $this-&gt;supportsDescribeSchemaMapping; } var $supportsApplySchema = FALSE; function supportsApplySchema() { return $this-&gt;supportsApplySchema; } var $supportsDestroySchema = FALSE; function supportsDestroySchema() { return $this-&gt;supportsDestroySchema; } var $supportsActivateSpatialContext = FALSE; function supportsActivateSpatialContext() { return $this-&gt;supportsActivateSpatialContext; } var $supportsCreateSpatialContext = FALSE; function supportsCreateSpatialContext() { return $this-&gt;supportsCreateSpatialContext; } var $supportsDestroySpatialContext = FALSE; function supportsDestroySpatialContext() { return $this-&gt;supportsDestroySpatialContext; } var $supportsGetSpatialContexts = FALSE; function supportsGetSpatialContexts() { return $this-&gt;supportsGetSpatialContexts; } var $supportsCreateMeasureUnit = FALSE; function supportsCreateMeasureUnit() { return $this-&gt;supportsCreateMeasureUnit; } var $supportsDestroyMeasureUnit = FALSE; function supportsDestroyMeasureUnit() { return $this-&gt;supportsDestroyMeasureUnit; } var $supportsGetMeasureUnits = FALSE; function supportsGetMeasureUnits() { return $this-&gt;supportsGetMeasureUnits; } var $supportsSQLCommand = FALSE; function supportsSQLCommand() { return $this-&gt;supportsSQLCommand; } var $supportsAcquireLock = FALSE; function supportsAcquireLock() { return $this-&gt;supportsAcquireLock; } var $supportsGetLockInfo = FALSE; function supportsGetLockInfo() { return $this-&gt;supportsGetLockInfo; } var $supportsGetLockedObjects = FALSE; function supportsGetLockedObjects() { return $this-&gt;supportsGetLockedObjects; } var $supportsGetLockOwners = FALSE; function supportsGetLockOwners() { return $this-&gt;supportsGetLockOwners; } var $supportsReleaseLock = FALSE; function supportsReleaseLock() { return $this-&gt;supportsReleaseLock; } var $supportsActivateLongTransaction = FALSE; function supportsActivateLongTransaction() { return $this-&gt;supportsActivateLongTransaction; } var $supportsCommitLongTransaction = FALSE; function supportsCommitLongTransaction() { return $this-&gt;supportsCommitLongTransaction; } var $supportsCreateLongTransaction = FALSE; function supportsCreateLongTransaction() { return $this-&gt;supportsCreateLongTransaction; } var $supportsGetLongTransactions = FALSE; function supportsGetLongTransactions() { return $this-&gt;supportsGetLongTransactions; } var $supportsFreezeLongTransaction = FALSE; function supportsFreezeLongTransaction() { return $this-&gt;supportsFreezeLongTransaction; } var $supportsRollbackLongTransaction = FALSE; function supportsRollbackLongTransaction() { return $this-&gt;supportsRollbackLongTransaction; } var $supportsActivateLongTransactionCheckpoint = FALSE; function supportsActivateLongTransactionCheckpoint() { return $this-&gt;supportsActivateLongTransactionCheckpoint; } var $supportsCreateLongTransactionCheckpoint = FALSE; function supportsCreateLongTransactionCheckpoint() { return $this-&gt;supportsCreateLongTransactionCheckpoint; } var $supportsGetLongTransactionCheckpoints = FALSE; function supportsGetLongTransactionCheckpoints() { return $this-&gt;supportsGetLongTransactionCheckpoints; } var $supportsRollbackLongTransactionCheckpoint = FALSE; function supportsRollbackLongTransactionCheckpoint() { return $this-&gt;supportsRollbackLongTransactionCheckpoint; } var $supportsChangeLongTransactionPrivileges = FALSE; function supportsChangeLongTransactionPrivileges() { return $this-&gt;supportsChangeLongTransactionPrivileges; } var $supportsGetLongTransactionPrivileges = FALSE; function supportsGetLongTransactionPrivileges() { return $this-&gt;supportsGetLongTransactionPrivileges; } var $supportsChangeLongTransactionSet = FALSE; function supportsChangeLongTransactionSet() { return $this-&gt;supportsChangeLongTransactionSet; } var $supportsGetLongTransactionsInSet = FALSE; function supportsGetLongTransactionsInSet() { return $this-&gt;supportsGetLongTransactionsInSet; } var $supportsFirstProviderCommand = FALSE; function supportsFirstProviderCommand() { return $this-&gt;supportsFirstProviderCommand; } var $supportsDeactivateLongTransaction = FALSE; function supportsDeactivateLongTransaction() { return $this-&gt;supportsDeactivateLongTransaction; } // rest of Commands var $supportsParameters = FALSE; function supportsParameters() { return $this-&gt;supportsParameters; } var $supportsCommandTimeout = FALSE; function supportsCommandTimeout() { return $this-&gt;supportsCommandTimeout; } var $supportsSelectExpressions = FALSE; function supportsSelectExpressions() { return $this-&gt;supportsSelectExpressions; } var $supportsSelectFunctions = FALSE; function supportsSelectFunctions() { return $this-&gt;supportsSelectFunctions; } var $supportsSelectDistinct = FALSE; function supportsSelectDistinct() { return $this-&gt;supportsSelectDistinct; } var $supportsSelectOrdering = FALSE; function supportsSelectOrdering() { return $this-&gt;supportsSelectOrdering; } var $supportsSelectGrouping = FALSE; function supportsSelectGrouping() { return $this-&gt;supportsSelectGrouping; } function queryCommand() { $this-&gt;queryCommands(); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsParameters&quot;, $this-&gt;supportsParameters); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsTimeout&quot;, $this-&gt;supportsCommandTimeout); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsSelectExpressions&quot;, $this-&gt;supportsSelectExpressions); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsSelectFunctions&quot;, $this-&gt;supportsSelectFunctions); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsSelectDistinct&quot;, $this-&gt;supportsSelectDistinct); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsSelectOrdering&quot;, $this-&gt;supportsSelectOrdering); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Command/SupportsSelectGrouping&quot;, $this-&gt;supportsSelectGrouping); } function queryCommands() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Command/SupportedCommands/Name&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Insert&quot; : $this-&gt;supportsInsert = TRUE; break; case &quot;Delete&quot; : $this-&gt;supportsDelete = TRUE; break; case &quot;Update&quot; : $this-&gt;supportsUpdate = TRUE; break; case &quot;Select&quot; : $this-&gt;supportsSelect = TRUE; break; case &quot;SelectAggregates&quot; : $this-&gt;supportsSelectAggregates = TRUE; break; case &quot;DescribeSchema&quot; : $this-&gt;supportsDescribeSchema = TRUE; break; case &quot;DescribeSchemaMapping&quot; : $this-&gt;supportsDescribeSchemaMapping = TRUE; break; case &quot;DestroySchema&quot; : $this-&gt;supportsDestroySchema = TRUE; break; case &quot;ApplySchema&quot; : $this-&gt;supportsApplySchema = TRUE; break; case &quot;SQLCommand&quot; : $this-&gt;supportsSQLCommand = TRUE; break; case &quot;ActivateSpatialContext&quot; : $this-&gt;supportsActivateSpatialContext = TRUE; break; case &quot;CreateSpatialContext&quot; : $this-&gt;supportsCreateSpatialContext = TRUE; break; case &quot;DestroySpatialContext&quot; : $this-&gt;supportsDestroySpatialContext = TRUE; break; case &quot;GetSpatialContexts&quot; : $this-&gt;supportsGetSpatialContexts = TRUE; break; case &quot;CreateMeasureUnit&quot; : $this-&gt;supportsCreateMeasureUnit = TRUE; break; case &quot;DestroyMeasureUnit&quot; : $this-&gt;supportsDestroyMeasureUnit = TRUE; break; case &quot;GetMeasureUnits&quot; : $this-&gt;supportsGetMeasureUnits = TRUE; break; case &quot;AcquireLock&quot; : $this-&gt;supportsAcquireLock = TRUE; break; case &quot;GetLockInfo&quot; : $this-&gt;supportsGetLockInfo = TRUE; break; case &quot;GetLockedObjects&quot; : $this-&gt;supportsGetLockedObjects = TRUE; break; case &quot;GetLockOwners&quot; : $this-&gt;supportsGetLockOwners = TRUE; break; case &quot;ReleaseLock&quot; : $this-&gt;supportsReleaseLock = TRUE; break; case &quot;ActivateLongTransaction&quot; : $this-&gt;supportsActivateLongTransaction = TRUE; break; case &quot;CommitLongTransaction&quot; : $this-&gt;supportsCommitLongTransaction = TRUE; break; case &quot;CreateLongTransaction&quot; : $this-&gt;supportsCreateLongTransaction = TRUE; break; case &quot;GetLongTransactions&quot; : $this-&gt;supportsGetLongTransactions = TRUE; break; case &quot;FreezeLongTransaction&quot; : $this-&gt;supportsFreezeLongTransaction = TRUE; break; case &quot;RollbackLongTransaction&quot; : $this-&gt;supportsRollbackLongTransaction = TRUE; break; case &quot;ActivateLongTransactionCheckpoint&quot; : $this-&gt;supportsActivateLongTransactionCheckpoint = TRUE; break; case &quot;CreateLongTransactionCheckpoint&quot; : $this-&gt;supportsCreateLongTransactionCheckpoint = TRUE; break; case &quot;GetLongTransactionCheckpoints&quot; : $this-&gt;supportsGetLongTransactionCheckpoints = TRUE; break; case &quot;RollbackLongTransactionCheckpoint&quot; : $this-&gt;supportsRollbackLongTransactionCheckpoint = TRUE; break; case &quot;ChangeLongTransactionPrivileges&quot; : $this-&gt;supportsChangeLongTransactionPrivileges = TRUE; break; case &quot;GetLongTransactionPrivileges&quot; : $this-&gt;supportsGetLongTransactionPrivileges = TRUE; break; case &quot;ChangeLongTransactionSet&quot; : $this-&gt;supportsChangeLongTransactionSet = TRUE; break; case &quot;GetLongTransactionsInSet&quot; : $this-&gt;supportsGetLongTransactionsInSet = TRUE; break; case &quot;FirstProviderCommand&quot; : $this-&gt;supportsFirstProviderCommand = TRUE; break; case &quot;DeactivateLongTransaction&quot; : $this-&gt;supportsDeactivateLongTransaction = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown command type: $value\\\\n&quot;); } } } // FILTER // Condition types var $supportsComparison = FALSE; function supportsComparison() { return $this-&gt;supportsComparison; } var $supportsLike = FALSE; function supportsLike() { return $this-&gt;supportsLike; } var $supportsIn = FALSE; function supportsIn() { return $this-&gt;supportsIn; } var $supportsNull = FALSE; function supportsNull() { return $this-&gt;supportsNull; } var $supportsSpatial = FALSE; function supportsSpatial() { return $this-&gt;supportsSpatial; } var $supportsDistance = FALSE; function supportsDistance() { return $this-&gt;supportsDistance; } // Spatial types var $supportsContains = FALSE; function supportsContains() { return $this-&gt;supportsContains; } var $supportsCrosses = FALSE; function supportsCrosses() { return $this-&gt;supportsCrosses; } var $supportsDisjoint = FALSE; function supportsDisjoint() { return $this-&gt;supportsDisjoint; } var $supportsEquals = FALSE; function supportsEquals() { return $this-&gt;supportsEquals; } var $supportsIntersects = FALSE; function supportsIntersects() { return $this-&gt;supportsIntersects; } var $supportsOverlaps = FALSE; function supportsOverlaps() { return $this-&gt;supportsOverlaps; } var $supportsTouches = FALSE; function supportsTouches() { return $this-&gt;supportsTouches; } var $supportsSpatialWithin = FALSE; function supportsSpatialWithin() { return $this-&gt;supportsSpatialWithin; } var $supportsCoveredBy = FALSE; function supportsCoveredBy() { return $this-&gt;supportsCoveredBy; } var $supportsInside = FALSE; function supportsInside() { return $this-&gt;supportsInside; } var $supportsEnvelopeIntersects = FALSE; function supportsEnvelopeIntersects() { return $this-&gt;supportsEnvelopeIntersects; } // Distance types var $supportsBeyond = FALSE; function supportsBeyond() { return $this-&gt;supportsBeyond; } var $supportsDistanceWithin = FALSE; function supportsDistanceWithin() { return $this-&gt;supportsDistanceWithin; } // rest of Filter var $supportsGeodesicDistance = FALSE; function supportsGeodesicDistance() { return $this-&gt;supportsGeodesicDistance; } var $supportsNonLiteralGeometricOperations = FALSE; function supportsNonLiteralGeometricOperations() { return $this-&gt;supportsNonLiteralGeometricOperations; } function queryFilter() { $this-&gt;queryConditionType(); $this-&gt;querySpatialOperations(); $this-&gt;queryDistanceOperations(); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Filter/SupportsGeodesicDistance&quot;, $this-&gt;supportsGeodesicDistance); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Filter/SupportsNonLiteralGeometricOperations&quot;, $this-&gt;supportsNonLiteralGeometricOperations); } function queryConditionType() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Filter/Condition/Type&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Comparison&quot; : $this-&gt;supportsComparison = TRUE; break; case &quot;Like&quot; : $this-&gt;supportsLike = TRUE; break; case &quot;In&quot; : $this-&gt;supportsIn = TRUE; break; case &quot;Null&quot; : $this-&gt;supportsNull = TRUE; break; case &quot;Spatial&quot; : $this-&gt;supportsSpatial = TRUE; break; case &quot;Distance&quot; : $this-&gt;supportsDistance = TRUE; break; ; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown filter condition type: $value\\\\n&quot;); } } } function querySpatialOperations() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Filter/Spatial/Operation&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Contains&quot; : $this-&gt;supportsContains = TRUE; break; case &quot;Crosses&quot; : $this-&gt;supportsCrosses = TRUE; break; case &quot;Disjoint&quot; : $this-&gt;supportsDisjoint = TRUE; break; case &quot;Equals&quot; : $this-&gt;supportsEquals = TRUE; break; case &quot;Intersects&quot; : $this-&gt;supportsIntersects = TRUE; break; case &quot;Overlaps&quot; : $this-&gt;supportsOverlaps = TRUE; break; case &quot;Touches&quot; : $this-&gt;supportsTouches = TRUE; break; case &quot;Within&quot; : $this-&gt;supportsSpatialWithin = TRUE; break; case &quot;CoveredBy&quot; : $this-&gt;supportsCoveredBy = TRUE; break; case &quot;Inside&quot; : $this-&gt;supportsInside = TRUE; break; case &quot;EnvelopeIntersects&quot; : $this-&gt;supportsEnvelopeIntersects = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown filter spatial operation: $value\\\\n&quot;); } } } function queryDistanceOperations() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Filter/Distance/Operation&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Within&quot; : $this-&gt;supportsDistanceWithin = TRUE; break; case &quot;Beyond&quot; : $this-&gt;supportsBeyond = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown filter distance operation: $value\\\\n&quot;); } } } // EXPRESSION // types var $supportsBasic = FALSE; function supportsBasic() { return $this-&gt;supportsBasic; } var $supportsFunction = FALSE; function supportsFunction() { return $this-&gt;supportsFunction; } var $supportsParameter = FALSE; function supportsParameter() { return $this-&gt;supportsParameter; } var $supportsAvg = FALSE; function supportsAvg() { return $this-&gt;supportsAvg; } var $supportsCeil = FALSE; function supportsCeil() { return $this-&gt;supportsCeil; } var $supportsCLIP = FALSE; function supportsCLIP() { return $this-&gt;supportsCLIP; } var $supportsConcat = FALSE; function supportsConcat() { return $this-&gt;supportsConcat; } var $supportsCount = FALSE; function supportsCount() { return $this-&gt;supportsCount; } var $supportsFloor = FALSE; function supportsFloor() { return $this-&gt;supportsFloor; } var $supportsLower = FALSE; function supportsLower() { return $this-&gt;supportsLower; } var $supportsMax = FALSE; function supportsMax() { return $this-&gt;supportsMax; } var $supportsMin = FALSE; function supportsMin() { return $this-&gt;supportsMin; } var $supportsMOSAIC = FALSE; function supportsMOSAIC() { return $this-&gt;supportsMOSAIC; } var $supportsStdDev = FALSE; function supportsStdDev() { return $this-&gt;supportsStdDev; } var $supportsSum = FALSE; function supportsSum() { return $this-&gt;supportsSum; } var $supportsUpper = FALSE; function supportsUpper() { return $this-&gt;supportsUpper; } function queryExpression() { $this-&gt;queryExpressionType(); $this-&gt;queryFunctionDefinitions(); } function queryExpressionType() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Expression/Type/Name&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Basic&quot; : $this-&gt;supportsBasic = TRUE; break; case &quot;Function&quot; : $this-&gt;supportsFunction = TRUE; break; case &quot;Parameter&quot; : $this-&gt;supportsParameter = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown filter distance operation: $value\\\\n&quot;); } } } function queryFunctionDefinitions() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Expression/FunctionDefinitionCollection/FunctionDefinition/Name&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Avg&quot; : $this-&gt;supportsAvg = TRUE; break; case &quot;Ceil&quot; : $this-&gt;supportsCeil = TRUE; break; case &quot;CLIP&quot; : $this-&gt;supportsCLIP = TRUE; break; case &quot;Concat&quot; : $this-&gt;supportsConcat = TRUE; break; case &quot;Count&quot; : $this-&gt;supportsCount = TRUE; break; case &quot;Floor&quot; : $this-&gt;supportsFloor = TRUE; break; case &quot;Lower&quot; : $this-&gt;supportsLower = TRUE; break; case &quot;Max&quot; : $this-&gt;supportsMax = TRUE; break; case &quot;Min&quot; : $this-&gt;supportsMin = TRUE; break; case &quot;MOSAIC&quot; : $this-&gt;supportsMOSAIC = TRUE; break; case &quot;StdDev&quot; : $this-&gt;supportsStdDev = TRUE; break; case &quot;Sum&quot; : $this-&gt;supportsSum = TRUE; break; case &quot;Upper&quot; : $this-&gt;supportsUpper = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown expression function name: $value\\\\n&quot;); } } } // RASTER var $supportsRaster = FALSE; function supportsRaster() { return $this-&gt;supportsRaster; } var $supportsStitching = FALSE; function supportsStitching() { return $this-&gt;supportsStitching; } var $supportsSubsampling = FALSE; function supportsSubsampling() { return $this-&gt;supportsSubsampling; } function queryRaster() { $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Raster/SupportsRaster&quot;, $this-&gt;supportsRaster); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Raster/SupportsStitching&quot;, $this-&gt;supportsStitching); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Raster/SupportsSubsampling&quot;, $this-&gt;supportsSubsampling); } // TOPOLOGY var $supportsTopology = FALSE; function supportsTopology() { return $this-&gt;supportsTopology; } var $supportsTopologicalHierarchy = FALSE; function supportsTopologicalHierarchy() { return $this-&gt;supportsTopologicalHierarchy; } var $supportsBreaksCurveCrossingsAutomatically = FALSE; function supportsBreaksCurveCrossingsAutomatically() { return $this-&gt;supportsBreaksCurveCrossingsAutomatically; } var $supportsActivatesTopologyByArea = FALSE; function supportsActivatesTopologyByArea() { return $this-&gt;supportsActivatesTopologyByArea; } var $supportsConstrainsFeatureMovements = FALSE; function supportsConstrainsFeatureMovements() { return $this-&gt;supportsConstrainsFeatureMovements; } function queryTopology() { $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Topology/SupportsTopology&quot;, $this-&gt;supportsTopology); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Topology/SupportsTopologicalHierarchy&quot;, $this-&gt;supportsTopologicalHierarchy); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Topology/BreaksCurveCrossingsAutomatically&quot;, $this-&gt;supportsBreaksCurveCrossingsAutomatically); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Topology/ActivatesTopologyByArea&quot;, $this-&gt;supportsActivatesTopologyByArea); $this-&gt;queryBooleanElement(&quot;//FeatureProviderCapabilities/Topology/ConstrainsFeatureMovements&quot;, $this-&gt;supportsConstrainsFeatureMovements); } // GEOMETRY var $supportsPoint = FALSE; function supportsPoint() { return $this-&gt;supportsPoint; } var $supportsMultiPoint = FALSE; function supportsMultiPoint() { return $this-&gt;supportsMultiPoint; } var $supportsLineString = FALSE; function supportsLineString() { return $this-&gt;supportsLineString; } var $supportsMultiLineString = FALSE; function supportsMultiLineString() { return $this-&gt;supportsMultiLineString; } var $supportsPolygon = FALSE; function supportsPolygon() { return $this-&gt;supportsPolygon; } var $supportsMultiPolygon = FALSE; function supportsMultiPolygon() { return $this-&gt;supportsMultiPolygon; } var $supportsCurveString = FALSE; function supportsCurveString() { return $this-&gt;supportsCurveString; } var $supportsMultiCurveString = FALSE; function supportsMultiCurveString() { return $this-&gt;supportsMultiCurveString; } var $supportsCurvePolygon = FALSE; function supportsCurvePolygon() { return $this-&gt;supportsCurvePolygon; } var $supportsMultiCurvePolygon = FALSE; function supportsMultiCurvePolygon() { return $this-&gt;supportsMultiCurvePolygon; } var $supportsMultiGeometry = FALSE; function supportsMultiGeometry() { return $this-&gt;supportsMultiGeometry; } var $supportsLinearRing = FALSE; function supportsLinearRing() { return $this-&gt;supportsLinearRing; } var $supportsLinearSegment = FALSE; function supportsLinearSegment() { return $this-&gt;supportsLinearSegment; } var $supportsArcSegment = FALSE; function supportsArcSegment() { return $this-&gt;supportsArcSegment; } var $supportsCurveRing = FALSE; function supportsCurveRing() { return $this-&gt;supportsCurveRing; } var $dimensionality = -1; function getDimensionality() { return $this-&gt;dimensionality; } function queryGeometry() { $this-&gt;queryGeometries(); $this-&gt;queryComponents(); $this-&gt;queryDimensionality(); } function queryGeometries() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Geometry/Type&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;Point&quot; : $this-&gt;supportsPoint = TRUE; break; case &quot;MultiPoint&quot; : $this-&gt;supportsMultiPoint = TRUE; break; case &quot;LineString&quot; : $this-&gt;supportsLineString = TRUE; break; case &quot;MultiLineString&quot; : $this-&gt;supportsMultiLineString = TRUE; break; case &quot;Polygon&quot; : $this-&gt;supportsPolygon = TRUE; break; case &quot;MultiPolygon&quot; : $this-&gt;supportsMultiPolygon = TRUE; break; case &quot;CurveString&quot; : $this-&gt;supportsCurveString = TRUE; break; case &quot;MultiCurveString&quot; : $this-&gt;supportsMultiCurveString = TRUE; break; case &quot;CurvePolygon&quot; : $this-&gt;supportsCurvePolygon = TRUE; break; case &quot;MultiCurvePolygon&quot; : $this-&gt;supportsMultiCurvePolygon = TRUE; break; case &quot;MultiGeometry&quot; : $this-&gt;supportsMultiGeometry = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown geometry type: $value\\\\n&quot;); } } } function queryComponents() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Geometry/Components/Type&quot;); $count = $domNodeList-&gt;length; for($i=0; $i&lt;$count; $i++) { $domNode = $domNodeList-&gt;item($i); $value = $domNode-&gt;nodeValue; switch($value) { case &quot;LinearRing&quot; : $this-&gt;supportsLinearRing = TRUE; break; case &quot;LinearSegment&quot; : $this-&gt;supportsLinearSegment = TRUE; break; case &quot;ArcSegment&quot; : $this-&gt;supportsArcSegment = TRUE; break; case &quot;CurveRing&quot; : $this-&gt;supportsCurveRing = TRUE; break; default : fwrite($this-&gt;logFileHandle, &quot;unknown geometry component type: $value\\\\n&quot;); } } } function queryDimensionality() { $domNodeList = $this-&gt;xpath-&gt;query(&quot;//FeatureProviderCapabilities/Geometry/Dimensionality&quot;); if ($domNodeList-&gt;length == 0) return; $domNode = $domNodeList-&gt;item(0); $value = $domNode-&gt;nodeValue; $this-&gt;dimensionality = $value; } function logCapabilities() { fwrite($this-&gt;logFileHandle, &quot;Capabilities for $this-&gt;providerName\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;Connection\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tThreadCapability\\\\n&quot;); $logEntry = &quot;\\\\t\\\\tsupportsSingleThreaded(): &quot; . $this-&gt;prtBool($this-&gt;supportsSingleThreaded()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsPerConnectionThreaded(): &quot; . $this-&gt;prtBool($this-&gt;supportsPerConnectionThreaded()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsPerCommandThreaded(): &quot; . $this-&gt;prtBool($this-&gt;supportsPerCommandThreaded()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiThreaded(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiThreaded()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tSpatialContextExtent\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDynamic(): &quot; . $this-&gt;prtBool($this-&gt;supportsDynamic()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsStatic(): &quot; . $this-&gt;prtBool($this-&gt;supportsStatic()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsLocking(): &quot; . $this-&gt;prtBool($this-&gt;supportsLocking()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsConnectionTimeout(): &quot; . $this-&gt;prtBool($this-&gt;supportsConnectionTimeout()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsTransactions(): &quot; . $this-&gt;prtBool($this-&gt;supportsTransactions()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsLongTransactions(): &quot; . $this-&gt;prtBool($this-&gt;supportsLongTransactions()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSQL(): &quot; . $this-&gt;prtBool($this-&gt;supportsSQL()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsConfiguration(): &quot; . $this-&gt;prtBool($this-&gt;supportsConfiguration()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Schema\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tClass\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsClass(): &quot; . $this-&gt;prtBool($this-&gt;supportsClass()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsFeatureClass(): &quot; . $this-&gt;prtBool($this-&gt;supportsFeatureClass()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tData\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsBoolean(): &quot; . $this-&gt;prtBool($this-&gt;supportsBoolean()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsByte(): &quot; . $this-&gt;prtBool($this-&gt;supportsByte()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDateTime(): &quot; . $this-&gt;prtBool($this-&gt;supportsDateTime()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDecimal(): &quot; . $this-&gt;prtBool($this-&gt;supportsDecimal()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDouble(): &quot; . $this-&gt;prtBool($this-&gt;supportsDouble()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsInt16(): &quot; . $this-&gt;prtBool($this-&gt;supportsInt16()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsInt32(): &quot; . $this-&gt;prtBool($this-&gt;supportsInt32()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsInt64(): &quot; . $this-&gt;prtBool($this-&gt;supportsInt64()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSingle(): &quot; . $this-&gt;prtBool($this-&gt;supportsSingle()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsString(): &quot; . $this-&gt;prtBool($this-&gt;supportsString()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsBLOB(): &quot; . $this-&gt;prtBool($this-&gt;supportsBLOB()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCLOB(): &quot; . $this-&gt;prtBool($this-&gt;supportsCLOB()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsUniqueID(): &quot; . $this-&gt;prtBool($this-&gt;supportsUniqueID()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsInheritance(): &quot; . $this-&gt;prtBool($this-&gt;supportsInheritance()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsMultipleSchemas(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultipleSchemas()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsObjectProperties(): &quot; . $this-&gt;prtBool($this-&gt;supportsObjectProperties()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsAssociationProperties(): &quot; . $this-&gt;prtBool($this-&gt;supportsAssociationProperties()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSchemaOverrides(): &quot; . $this-&gt;prtBool($this-&gt;supportsSchemaOverrides()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsNetworkModel(): &quot; . $this-&gt;prtBool($this-&gt;supportsNetworkModel()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsAutoIdGeneration(): &quot; . $this-&gt;prtBool($this-&gt;supportsAutoIdGeneration()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsDataStoreScopeUniqueIdGeneration(): &quot; . $this-&gt;prtBool($this-&gt;supportsDataStoreScopeUniqueIdGeneration()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSchemaModification(): &quot; . $this-&gt;prtBool($this-&gt;supportsSchemaModification()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Command\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tSupportedCommands\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tName\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSelect(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelect()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsInsert(): &quot; . $this-&gt;prtBool($this-&gt;supportsInsert()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDelete(): &quot; . $this-&gt;prtBool($this-&gt;supportsDelete()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsUpdate(): &quot; . $this-&gt;prtBool($this-&gt;supportsUpdate()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSelectAggregates(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectAggregates()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDescribeSchema(): &quot; . $this-&gt;prtBool($this-&gt;supportsDescribeSchema()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDescribeSchemaMapping(): &quot; . $this-&gt;prtBool($this-&gt;supportsDescribeSchemaMapping()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDestroySchema(): &quot; . $this-&gt;prtBool($this-&gt;supportsDestroySchema()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsApplySchema(): &quot; . $this-&gt;prtBool($this-&gt;supportsApplySchema()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsActivateSpatialContext(): &quot; . $this-&gt;prtBool($this-&gt;supportsActivateSpatialContext()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCreateSpatialContext(): &quot; . $this-&gt;prtBool($this-&gt;supportsCreateSpatialContext()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDestroySpatialContext(): &quot; . $this-&gt;prtBool($this-&gt;supportsDestroySpatialContext()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDestroySpatialContext(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetSpatialContexts) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCreateMeasureUnit(): &quot; . $this-&gt;prtBool($this-&gt;supportsCreateMeasureUnit()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDestroyMeasureUnit()t: &quot; . $this-&gt;prtBool($this-&gt;supportsDestroyMeasureUnit()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetMeasureUnits(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetMeasureUnits()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSQLCommand(): &quot; . $this-&gt;prtBool($this-&gt;supportsSQLCommand()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsAcquireLock(): &quot; . $this-&gt;prtBool($this-&gt;supportsAcquireLock()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLockInfo(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLockInfo()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLockedObjects(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLockedObjects()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLockOwners(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLockOwners()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsReleaseLock(): &quot; . $this-&gt;prtBool($this-&gt;supportsReleaseLock()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsActivateLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsActivateLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCommitLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsCommitLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCreateLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsCreateLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLongTransactions(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLongTransactions()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsFreezeLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsFreezeLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsRollbackLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsRollbackLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsActivateLongTransactionCheckpoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsActivateLongTransactionCheckpoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCreateLongTransactionCheckpoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsCreateLongTransactionCheckpoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLongTransactionCheckpoints(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLongTransactionCheckpoints()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsRollbackLongTransactionCheckpoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsRollbackLongTransactionCheckpoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsChangeLongTransactionPrivileges(): &quot; . $this-&gt;prtBool($this-&gt;supportsChangeLongTransactionPrivileges()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLongTransactionPrivileges(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLongTransactionPrivileges()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsChangeLongTransactionSet(): &quot; . $this-&gt;prtBool($this-&gt;supportsChangeLongTransactionSet()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsGetLongTransactionsInSet(): &quot; . $this-&gt;prtBool($this-&gt;supportsGetLongTransactionsInSet()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsFirstProviderCommand(): &quot; . $this-&gt;prtBool($this-&gt;supportsFirstProviderCommand()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDeactivateLongTransaction(): &quot; . $this-&gt;prtBool($this-&gt;supportsDeactivateLongTransaction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsParameters(): &quot; . $this-&gt;prtBool($this-&gt;supportsParameters()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsCommandTimeout(): &quot; . $this-&gt;prtBool($this-&gt;supportsCommandTimeout()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSelectExpressions(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectExpressions()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSelectFunctions(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectFunctions()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSelectDistinct(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectDistinct()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSelectOrdering(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectOrdering()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSelectGrouping(): &quot; . $this-&gt;prtBool($this-&gt;supportsSelectGrouping()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Filter\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tCondition\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsComparison(): &quot; . $this-&gt;prtBool($this-&gt;supportsComparison()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsLike(): &quot; . $this-&gt;prtBool($this-&gt;supportsLike()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsIn(): &quot; . $this-&gt;prtBool($this-&gt;supportsIn()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsNull(): &quot; . $this-&gt;prtBool($this-&gt;supportsNull()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSpatial(): &quot; . $this-&gt;prtBool($this-&gt;supportsSpatial()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDistance(): &quot; . $this-&gt;prtBool($this-&gt;supportsDistance()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tSpatial\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tOperation\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsContains(): &quot; . $this-&gt;prtBool($this-&gt;supportsContains()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCrosses(): &quot; . $this-&gt;prtBool($this-&gt;supportsCrosses()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDisjoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsDisjoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsEquals(): &quot; . $this-&gt;prtBool($this-&gt;supportsEquals()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsIntersects(): &quot; . $this-&gt;prtBool($this-&gt;supportsIntersects()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsOverlaps()s: &quot; . $this-&gt;prtBool($this-&gt;supportsOverlaps()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsTouches(): &quot; . $this-&gt;prtBool($this-&gt;supportsTouches()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsSpatialWithin(): &quot; . $this-&gt;prtBool($this-&gt;supportsSpatialWithin()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCoveredBy(): &quot; . $this-&gt;prtBool($this-&gt;supportsCoveredBy()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsInside(): &quot; . $this-&gt;prtBool($this-&gt;supportsInside()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsEnvelopeIntersects(): &quot; . $this-&gt;prtBool($this-&gt;supportsEnvelopeIntersects()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tDistance\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tOperation\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsDistanceWithin(): &quot; . $this-&gt;prtBool($this-&gt;supportsDistanceWithin()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsBeyond(): &quot; . $this-&gt;prtBool($this-&gt;supportsBeyond()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsGeodesicDistance(): &quot; . $this-&gt;prtBool($this-&gt;supportsGeodesicDistance()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsNonLiteralGeometricOperations(): &quot; . $this-&gt;prtBool($this-&gt;supportsNonLiteralGeometricOperations()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Expression\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tType\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tName\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsBasic(): &quot; . $this-&gt;prtBool($this-&gt;supportsBasic()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsFunction(): &quot; . $this-&gt;prtBool($this-&gt;supportsFunction()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsParameter(): &quot; . $this-&gt;prtBool($this-&gt;supportsParameter()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tFunctionDefinitionCollection\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tFunctionDefinition\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\t\\\\tName\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsAvg(): &quot; . $this-&gt;prtBool($this-&gt;supportsAvg()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsCeil(): &quot; . $this-&gt;prtBool($this-&gt;supportsCeil()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsCLIP(): &quot; . $this-&gt;prtBool($this-&gt;supportsCLIP()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsConcat(): &quot; . $this-&gt;prtBool($this-&gt;supportsConcat()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsCount(): &quot; . $this-&gt;prtBool($this-&gt;supportsCount()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsFloor(): &quot; . $this-&gt;prtBool($this-&gt;supportsFloor()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsLower(): &quot; . $this-&gt;prtBool($this-&gt;supportsLower()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsMax(): &quot; . $this-&gt;prtBool($this-&gt;supportsMax()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsMin(): &quot; . $this-&gt;prtBool($this-&gt;supportsMin()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsMOSAIC(): &quot; . $this-&gt;prtBool($this-&gt;supportsMOSAIC()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsStdDev(): &quot; . $this-&gt;prtBool($this-&gt;supportsStdDev()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsSum(): &quot; . $this-&gt;prtBool($this-&gt;supportsSum()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\t\\\\tsupportsUpper(): &quot; . $this-&gt;prtBool($this-&gt;supportsUpper()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Raster\\\\n&quot;); $logEntry = &quot;\\\\tsupportsRaster(): &quot; . $this-&gt;prtBool($this-&gt;supportsRaster()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsStitching(): &quot; . $this-&gt;prtBool($this-&gt;supportsStitching()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsSubsampling(): &quot; . $this-&gt;prtBool($this-&gt;supportsSubsampling()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Topology\\\\n&quot;); $logEntry = &quot;\\\\tsupportsTopology(): &quot; . $this-&gt;prtBool($this-&gt;supportsTopology()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsTopologicalHierarchy(): &quot; . $this-&gt;prtBool($this-&gt;supportsTopologicalHierarchy()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsBreaksCurveCrossingsAutomatically(): &quot; . $this-&gt;prtBool($this-&gt;supportsBreaksCurveCrossingsAutomatically()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsActivatesTopologyByArea(): &quot; . $this-&gt;prtBool($this-&gt;supportsActivatesTopologyByArea()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tsupportsConstrainsFeatureMovements(): &quot; . $this-&gt;prtBool($this-&gt;supportsConstrainsFeatureMovements()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;Geometry\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\tsupportsPoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsPoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiPoint(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiPoint()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsLineString(): &quot; . $this-&gt;prtBool($this-&gt;supportsLineString()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiLineString(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiLineString()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsPolygon(): &quot; . $this-&gt;prtBool($this-&gt;supportsPolygon()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiPolygon(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiPolygon()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsCurveString(): &quot; . $this-&gt;prtBool($this-&gt;supportsCurveString()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiCurveString(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiCurveString()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsCurvePolygon(): &quot; . $this-&gt;prtBool($this-&gt;supportsCurvePolygon()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiCurvePolygon(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiCurvePolygon()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\tsupportsMultiGeometry(): &quot; . $this-&gt;prtBool($this-&gt;supportsMultiGeometry()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); fwrite($this-&gt;logFileHandle, &quot;\\\\tComponents\\\\n&quot;); fwrite($this-&gt;logFileHandle, &quot;\\\\t\\\\tType\\\\n&quot;); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsLinearRing(): &quot; . $this-&gt;prtBool($this-&gt;supportsLinearRing()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsLinearSegment(): &quot; . $this-&gt;prtBool($this-&gt;supportsLinearSegment()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsArcSegment(): &quot; . $this-&gt;prtBool($this-&gt;supportsArcSegment()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\t\\\\t\\\\tsupportsCurveRing(): &quot; . $this-&gt;prtBool($this-&gt;supportsCurveRing()) . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); $logEntry = &quot;\\\\tdimensionality(): &quot; . $this-&gt;getDimensionality() . &quot;\\\\n&quot;; fwrite($this-&gt;logFileHandle, $logEntry); } }"
  },
  "topics/feature-schema.html": {
    "href": "topics/feature-schema.html",
    "title": "Feature Schema | MapGuide API Reference",
    "keywords": "Feature Schema A feature schema is a class or set of classes that define the structure of data contained in a feature source (datastore), for example, an Oracle database. A feature class consists of a set of properties. Each property has a set of attributes appropriate to the type of information it contains. Class and property here correspond roughly to table and column in a relational database. The class and property definition classes have methods for both getting and setting attributes. In general, however, the set methods are of no use except in the case of the FDO Provider for SDF. MgFeatureService::CreateFeatureSource permits you to create an SDF schema, that is, an SDF file containing a schema. The intent is that this method be used as part of a mechanism for caching feature data locally. The schema used for this SDF cache file would typically be the schema extracted by MgFeatureService::DescribeSchema from the feature source whose features are being cached. It is possible to create a schema from scratch; see the sample code below. Five property types are distinguished, and there is a property definition class for each type. The five types are: Simple data. The MgDataPropertyDefinition (.net, Java, PHP) class is used to define the attributes of simple data properties. The simple data types are BLOB, boolean, byte, CLOB, MgDateTime, double, Int16, Int32, Int64, single, and string. Geometry data. The MgGeometricPropertyDefinition (.net, Java, PHP) class is used to define the attributes of geometry data. The geometry data type is MgGeometry. Association data. The MgAssociationPropertyDefinition (.net, Java, PHP) class is used to define the attributes of association properties. This is not currently used. Object data. The MgObjectPropertyDefinition (.net, Java, PHP) class is used to define the attributes of object data. This allows us to model information using object composition. The type of object data is user-defined. Raster data. The MgRasterPropertyDefinition (.net, Java, PHP) class is used to define the attributes of raster data. The type of raster data is MgRaster (.net, Java, PHP). using OSGeo.MapGuide; MgDataPropertyDefinition dataProperty; MgGeometricPropertyDefinition geometricProperty; MgClassDefinition classDef = new MgClassDefinition(); className = \"SdfFeatureClass\"; classDef.SetName(className); classDef.SetDefaultGeometryPropertyName(\"theFeatureGeometry\"); // feature geometry property that takes 2D XY geometries geometricProperty = new MgGeometricPropertyDefinition(\"theFeatureGeometry\"); geometricProperty.SetGeometryTypes(MgFeatureGeometricType.Point | MgFeatureGeometricType.Curve | MgFeatureGeometricType.Surface); geometricProperty.SetHasElevation(false); geometricProperty.SetHasMeasure(false); geometricProperty.SetReadOnly(false); geometricProperty.SetSpatialContextAssociation(spatialContextName); classDef.GetProperties().Add(geometricProperty); // non-feature geometry geometricProperty = new MgGeometricPropertyDefinition(\"aNonFeatureGeometry\"); geometricProperty.SetGeometryTypes(MgFeatureGeometricType.Point | MgFeatureGeometricType.Curve | MgFeatureGeometricType.Surface); geometricProperty.SetHasElevation(false); geometricProperty.SetHasMeasure(false); geometricProperty.SetReadOnly(false); geometricProperty.SetSpatialContextAssociation(spatialContextName); classDef.GetProperties().Add(geometricProperty); // identity property dataProperty = new MgDataPropertyDefinition(\"FeatId\"); dataProperty.SetDataType(MgPropertyType.Int32); dataProperty.SetAutoGeneration(false); dataProperty.SetNullable(false); dataProperty.SetReadOnly(true); classDef.GetIdentityProperties().Add(dataProperty); classDef.GetProperties().Add(dataProperty); // boolean property dataProperty = new MgDataPropertyDefinition(\"aBoolean\"); dataProperty.SetDataType(MgPropertyType.Boolean); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // byte property dataProperty = new MgDataPropertyDefinition(\"aByte\"); dataProperty.SetDataType(MgPropertyType.Byte); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // DataTime property dataProperty = new MgDataPropertyDefinition(\"aDateTime\"); dataProperty.SetDataType(MgPropertyType.DateTime); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // cannot create Decimal property because MgPropertyType.Decimal doesn't exist // even though SDF schema capabilities says that Decimal property is supported // double property dataProperty = new MgDataPropertyDefinition(\"aDouble\"); dataProperty.SetDataType(MgPropertyType.Double); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // Int16 property dataProperty = new MgDataPropertyDefinition(\"anInt16\"); dataProperty.SetDataType(MgPropertyType.Int16); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // Int32 property dataProperty = new MgDataPropertyDefinition(\"anInt32\"); dataProperty.SetDataType(MgPropertyType.Int32); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // Int64 property dataProperty = new MgDataPropertyDefinition(\"anInt64\"); dataProperty.SetDataType(MgPropertyType.Int64); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // Single property dataProperty = new MgDataPropertyDefinition(\"aSingle\"); dataProperty.SetDataType(MgPropertyType.Single); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); // String property dataProperty = new MgDataPropertyDefinition(\"aString\"); dataProperty.SetDataType(MgPropertyType.String); dataProperty.SetNullable(true); dataProperty.SetReadOnly(false); classDef.GetProperties().Add(dataProperty); schema = new MgFeatureSchema(); schemaName = \"SdfFeatureClassSchema\"; schema.SetName(schemaName); schema.GetClasses().Add(classDef);"
  },
  "topics/geom-collections.html": {
    "href": "topics/geom-collections.html",
    "title": "Geometry Collections | MapGuide API Reference",
    "keywords": "Geometry Collections The following collection classes are used by MgGeometryFactory methods in the construction of geometries and geometry components. See the MgGeometryFactory description (.net, Java, PHP) for discussion and illustration of this use. Class MgCoordinateCollection (.net, Java, PHP) MgCurvePolygonCollection (.net, Java, PHP) MgCurveRingCollection (.net, Java, PHP) MgCurveSegmentCollection (.net, Java, PHP) MgCurveStringCollection (.net, Java, PHP) MgGeometryCollection (.net, Java, PHP) MgGeometryComponentCollection (.net, Java, PHP) MgLinearRingCollection (.net, Java, PHP) MgLineStringCollection (.net, Java, PHP) MgPointCollection (.net, Java, PHP) MgPolygonCollection (.net, Java, PHP)"
  }
}